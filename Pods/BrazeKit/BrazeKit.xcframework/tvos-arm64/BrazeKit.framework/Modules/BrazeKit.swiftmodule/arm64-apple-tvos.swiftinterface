// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-tvos12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Osize -module-name BrazeKit
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CommonCrypto
import Dispatch
import Foundation
import MachO
import Swift
import SystemConfiguration
import UIKit
import UserNotifications
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
@usableFromInline
internal protocol _AnyDecodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyEncodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension BrazeKit.Braze {
  @available(swift, obsoleted: 0.0.1)
  @objc final public func _requestEnableSDKOnNextAppRun()
  @available(swift, obsoleted: 0.0.1)
  @objc public static func _localize(_ key: Swift.String) -> Swift.String
  @available(swift, obsoleted: 0.0.1)
  @objc final public func _contentCardsApplyLocalCards()
  @available(swift, obsoleted: 0.0.1)
  @objc final public func _newsFeedApplyLocalCards()
}
extension BrazeKit.Braze {
  @available(swift, obsoleted: 0.0.1)
  @objc(delegate) final public var _objc_delegate: (any BrazeKit._OBJC_BrazeDelegate)? {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(inAppMessagePresenter) final public var _objc_inAppMessagePresenter: (any BrazeKit._OBJC_BrazeInAppMessagePresenter)? {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(updateTrackingAllowListAdding:removing:) final public func _objc_updateTrackingAllowList(adding: Swift.Set<BrazeKit._OBJC_BRZTrackingProperty>? = nil, removing: Swift.Set<BrazeKit._OBJC_BRZTrackingProperty>? = nil)
}
@_inheritsConvenienceInitializers @objc final public class Braze : ObjectiveC.NSObject {
  @objc(sdkVersion) public static let version: Swift.String
  @objc final public var enabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc final public let configuration: BrazeKit.Braze.Configuration
  @objc final public let user: BrazeKit.Braze.User
  @objc final public let notifications: BrazeKit.Braze.Notifications
  @objc final public let contentCards: BrazeKit.Braze.ContentCards
  @objc final public let newsFeed: BrazeKit.Braze.NewsFeed
  @objc final public let featureFlags: BrazeKit.Braze.FeatureFlags
  final public let liveActivities: BrazeKit.Braze.LiveActivities
  final public var inAppMessagePresenter: (any BrazeKit.BrazeInAppMessagePresenter)?
  weak final public var delegate: (any BrazeKit.BrazeDelegate)?
  @objc weak final public var sdkAuthDelegate: (any BrazeKit.BrazeSDKAuthDelegate)?
  @objc final public var deviceId: Swift.String {
    @objc get
  }
  @available(*, unavailable)
  @objc override dynamic public init()
  @objc public init(configuration: BrazeKit.Braze.Configuration)
  @objc deinit
}
@objc public enum _COMPAT_ABKRequestProcessingPolicy : Swift.Int {
  case manualRequestProcessing = 0
  case automaticRequestProcessing = 1
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum _COMPAT_ABKSDKFlavor : Swift.Int {
  case VANILLA
  case UNITY = 1
  case REACT
  case CORDOVA
  case XAMARIN
  case FLUTTER
  case SEGMENT
  case MPARTICLE
  case TEALIUM
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum _COMPAT_ABKSdkMetadata : Swift.String {
  case adjust
  case airBridge
  case appsFlyer
  case bluedot
  case branch
  case cordova
  case carthage
  case cocoaPods
  case cordovaPM
  case expo
  case foursquare
  case flutter
  case googleTagManager
  case gimbal
  case gradle
  case ionic
  case kochava
  case manual
  case mparticle
  case mParticle
  case nativeScript
  case NPM
  case nuGet
  case pub
  case radar
  case reactNative
  case reactNativeNewArch
  case segment
  case singular
  case swiftPM
  case tealium
  case unreal
  case unityPM
  case unity
  case vizbee
  case xamarin
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension BrazeKit.Braze {
  @available(*, deprecated, message: "BrazeKit does not provide a singleton instance. You are now expected to keep a reference of the Braze instance yourself after initialization.")
  @objc final public class func sharedInstance() -> BrazeKit.Braze?
  @available(*, deprecated, message: "BrazeKit does not provide a singleton instance. You are now expected to keep a reference of the Braze instance yourself after initialization.")
  @objc final public class func unsafeInstance() -> BrazeKit.Braze
  @available(*, deprecated, message: "Migrating the SDK initialization to the 'Braze(configuration:)' initializer disables most compatibility features. This step should be performed last in your migration process.\n\nAfter updating the SDK initialization and configuration, the SDK:\n- Will not read the `Info.plist` based SDK configuration.\n- Will not be compatible with `BrazeKitCompat` (`AppboyKit`) symbols.\n- Will not be compatible with `BrazeUICompat` (`AppboyUI`) UI components.\n- Will not emit the Content Cards and NewsFeed updates via the Notification Center.\n- Will not automatically use the `BrazeLocation` library.\n- Will not read the [`identifierForVendor`](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor) as part of the ``Braze/Configuration-swift.class/devicePropertyAllowList`` configuration.\n- Will not depend on [`SDWebImage`](https://github.com/SDWebImage/SDWebImage).\n- Will not support GIFs out of the box.\n\nSee our migration guide for instructions to properly migrate each feature: https://braze-inc.github.io/braze-swift-sdk/documentation/braze/appboy-migration-guide")
  @objc(startWithApiKey:inApplication:withLaunchOptions:) final public class func start(withApiKey apiKey: Swift.String, in application: UIKit.UIApplication, withLaunchOptions launchOptions: [Swift.AnyHashable : Any]? = nil)
  @available(*, deprecated, message: "Migrating the SDK initialization to the 'Braze(configuration:)' initializer disables most compatibility features. This step should be performed last in your migration process.\n\nAfter updating the SDK initialization and configuration, the SDK:\n- Will not read the `Info.plist` based SDK configuration.\n- Will not be compatible with `BrazeKitCompat` (`AppboyKit`) symbols.\n- Will not be compatible with `BrazeUICompat` (`AppboyUI`) UI components.\n- Will not emit the Content Cards and NewsFeed updates via the Notification Center.\n- Will not automatically use the `BrazeLocation` library.\n- Will not read the [`identifierForVendor`](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor) as part of the ``Braze/Configuration-swift.class/devicePropertyAllowList`` configuration.\n- Will not depend on [`SDWebImage`](https://github.com/SDWebImage/SDWebImage).\n- Will not support GIFs out of the box.\n\nSee our migration guide for instructions to properly migrate each feature: https://braze-inc.github.io/braze-swift-sdk/documentation/braze/appboy-migration-guide")
  @objc(startWithApiKey:inApplication:withLaunchOptions:withAppboyOptions:) final public class func start(withApiKey apiKey: Swift.String, in application: UIKit.UIApplication, withLaunchOptions launchOptions: [Swift.AnyHashable : Any]? = nil, withAppboyOptions appboyOptions: [Swift.AnyHashable : Any]? = nil)
  @available(*, deprecated, renamed: "newsFeed")
  @objc final public var feedController: Swift.AnyObject {
    @objc get
  }
  @available(*, deprecated, renamed: "contentCards")
  @objc final public var contentCardsController: Swift.AnyObject {
    @objc get
  }
  @available(*, deprecated, message: "request processing policy must be set using the 'Braze.Configuration' object at SDK initialization")
  @objc final public var requestProcessingPolicy: BrazeKit._COMPAT_ABKRequestProcessingPolicy {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "use 'set(identifierForAdvertiser:)' and 'set(adTrackingEnabled:)' instead")
  @objc final public var idfaDelegate: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @available(*, deprecated, renamed: "delegate")
  @objc final public var sdkAuthenticationDelegate: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @available(*, deprecated, renamed: "inAppMessagePresenter")
  @objc final public var inAppMessageController: Swift.AnyObject {
    @objc get
  }
  @available(*, deprecated, message: "use 'configuration.location' to access location analytics settings")
  @objc final public var locationManager: Swift.AnyObject {
    @objc get
  }
  @available(*, deprecated, renamed: "delegate")
  @objc weak final public var appboyUrlDelegate: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "imageDelegate is not needed anymore")
  @objc final public var imageDelegate: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "SDK flavor must be set using the 'Braze.Configuration' object at SDK initialization")
  @objc final public var sdkFlavor: BrazeKit._COMPAT_ABKSDKFlavor {
    @objc get
    @objc set
  }
  @available(*, deprecated, renamed: "requestImmediateDataFlush()")
  @objc final public func flushDataAndProcessRequestQueue()
  @available(*, unavailable, message: "use the 'enabled' boolean property to disable / enable the SDK")
  @objc final public func shutdownServerCommunication()
  @available(*, deprecated, renamed: "changeUser(userId:)")
  final public func changeUser(_ userId: Swift.String)
  @available(*, deprecated, renamed: "changeUser(userId:sdkAuthSignature:)")
  final public func changeUser(_ userId: Swift.String, sdkAuthSignature: Swift.String?)
  @available(*, deprecated, renamed: "set(sdkAuthenticationSignature:)")
  @objc final public func setSdkAuthenticationSignature(_ signature: Swift.String)
  @available(*, deprecated, message: "unsubscribing from SDK authentication errors is not needed anymore")
  @objc final public func unsubscribeFromSdkAuthenticationErrors()
  @available(*, deprecated, renamed: "logCustomEvent(name:)")
  final public func logCustomEvent(_ eventName: Swift.String)
  @available(*, deprecated, renamed: "logCustomEvent(name:properties:)")
  @objc final public func logCustomEvent(_ eventName: Swift.String, withProperties properties: [Swift.AnyHashable : Any]?)
  @available(*, deprecated, renamed: "logPurchase(productId:currency:price:)")
  @objc final public func logPurchase(_ productIdentifier: Swift.String, inCurrency currencyCode: Swift.String, atPrice price: Foundation.NSDecimalNumber)
  @available(*, deprecated, renamed: "logPurchase(productId:currency:price:properties:)")
  @objc final public func logPurchase(_ productIdentifier: Swift.String, inCurrency currencyCode: Swift.String, atPrice price: Foundation.NSDecimalNumber, withProperties properties: [Swift.AnyHashable : Any]?)
  @available(*, deprecated, renamed: "logPurchase(productId:currency:price:quantity:)")
  @objc final public func logPurchase(_ productIdentifier: Swift.String, inCurrency currencyCode: Swift.String, atPrice price: Foundation.NSDecimalNumber, withQuantity quantity: Swift.UInt)
  @available(*, deprecated, renamed: "logPurchase(productId:currency:price:quantity:properties:)")
  @objc final public func logPurchase(_ productIdentifier: Swift.String, inCurrency currencyCode: Swift.String, atPrice price: Foundation.NSDecimalNumber, withQuantity quantity: Swift.UInt, andProperties properties: [Swift.AnyHashable : Any]?)
  @available(*, deprecated, message: "logging the feed displayed event is not needed anymore")
  @objc final public func logFeedDisplayed()
  @available(*, deprecated, message: "logging the content cards displayed event is not needed anymore")
  @objc final public func logContentCardsDisplayed()
  @available(*, deprecated, message: "renamed to 'newsFeed.requestRefresh(_:)'")
  @objc final public func requestFeedRefresh()
  @available(*, deprecated, message: "renamed to 'contentCards.requestRefresh(_:)'")
  @objc final public func requestContentCardsRefresh()
  @available(*, deprecated, message: "renamed to 'requestGeofences(latitude:longitude:)'. ⚠️ Important: the order of the parameters have been changed")
  @objc final public func requestGeofences(withLongitude longitude: Swift.Double, latitude: Swift.Double)
  @available(*, deprecated, renamed: "deviceId")
  @objc final public func getDeviceId() -> Swift.String
  @available(*, deprecated, message: "SDK metadata must be set using the 'Braze.Configuration' object at SDK initialization")
  @objc final public func addSdkMetadata(_ metadata: [Swift.String])
  @available(*, deprecated, message: "SDK metadata must be set using the 'Braze.Configuration' object at SDK initialization")
  @nonobjc final public func addSdkMetadata(_ metadata: [BrazeKit._COMPAT_ABKSdkMetadata])
  @available(*, deprecated, message: "renamed to 'wipeData()' on the Braze instance")
  @objc final public class func wipeDataAndDisableForAppRun()
  @available(*, deprecated, message: "renamed to the 'enabled' boolean property")
  @objc final public class func disableSDK()
  @available(*, deprecated, message: "use the 'enabled' boolean property to disable / enable the SDK")
  @objc final public class func requestEnableSDKOnNextAppRun()
}
extension BrazeKit.Braze {
  @available(swift, obsoleted: 0.0.1)
  @objc(logCustomEvent:) final public func _objc_logCustomEvent(name: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(logCustomEvent:properties:) final public func _objc_logCustomEvent(name: Swift.String, properties: [Swift.String : Any]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(logPurchase:currency:price:) final public func _objc_logPurchase(productId: Swift.String, currency: Swift.String, price: Swift.Double)
  @available(swift, obsoleted: 0.0.1)
  @objc(logPurchase:currency:price:quantity:) final public func _objc_logPurchase(productId: Swift.String, currency: Swift.String, price: Swift.Double, quantity: Swift.Int)
  @available(swift, obsoleted: 0.0.1)
  @objc(logPurchase:currency:price:properties:) final public func _objc_logPurchase(productId: Swift.String, currency: Swift.String, price: Swift.Double, properties: [Swift.String : Any]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(logPurchase:currency:price:quantity:properties:) final public func _objc_logPurchase(productId: Swift.String, currency: Swift.String, price: Swift.Double, quantity: Swift.Int, properties: [Swift.String : Any]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(changeUser:) final public func _objc_changeUser(userId: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(changeUser:sdkAuthSignature:) final public func _objc_changeUser(userId: Swift.String, sdkAuthSignature: Swift.String?)
  @available(swift, obsoleted: 0.0.1)
  @objc(requestGeofencesWithLatitude:longitude:) final public func _objc_requestGeofences(latitude: Swift.Double, longitude: Swift.Double)
}
extension BrazeKit.Braze {
  final public func logCustomEvent(name: Swift.String, properties: [Swift.String : Any]? = nil, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func logPurchase(productId: Swift.String, currency: Swift.String, price: Swift.Double, quantity: Swift.Int = 1, properties: [Swift.String : Any]? = nil, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  final public func changeUser(userId: Swift.String, sdkAuthSignature: Swift.String? = nil, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  @objc(setSDKAuthenticationSignature:) final public func set(sdkAuthenticationSignature signature: Swift.String)
  @objc final public func requestImmediateDataFlush()
  final public func requestGeofences(latitude: Swift.Double, longitude: Swift.Double, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  @objc final public func wipeData()
  @objc(setIdentifierForVendor:) final public func set(identifierForVendor: Swift.String)
  @objc(setIdentifierForAdvertiser:) final public func set(identifierForAdvertiser: Swift.String)
  @objc(setAdTrackingEnabled:) final public func set(adTrackingEnabled: Swift.Bool)
  final public func updateTrackingAllowList(adding propertiesToAdd: Swift.Set<BrazeKit.Braze.Configuration.TrackingProperty> = [], removing propertiesToRemove: Swift.Set<BrazeKit.Braze.Configuration.TrackingProperty> = [])
}
@objc(BRZTriggerEvent) public enum _OBJC_TriggerEvent : Swift.Int {
  case sessionStart
  case customEvent
  case purchase
  case other
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc(BrazeDelegate) public protocol _OBJC_BrazeDelegate {
  @objc optional func braze(_ braze: BrazeKit.Braze, shouldOpenURL context: BrazeKit.Braze.URLContext) -> Swift.Bool
  @objc optional func braze(_ braze: BrazeKit.Braze, noMatchingTriggerForEvent event: BrazeKit._OBJC_TriggerEvent, name: Swift.String?, properties: [Swift.String : Any]?)
  @objc optional func braze(_ braze: BrazeKit.Braze, sdkAuthenticationFailedWithError error: BrazeKit.Braze.SDKAuthenticationError)
}
extension BrazeKit.Braze {
  public enum TriggerEvent {
    case sessionStart
    case customEvent(name: Swift.String, properties: [Swift.String : Any]?)
    case purchase(productId: Swift.String, properties: [Swift.String : Any]?)
    case other
    public var identifier: Swift.String? {
      get
    }
  }
}
public protocol BrazeDelegate : AnyObject {
  func braze(_ braze: BrazeKit.Braze, shouldOpenURL context: BrazeKit.Braze.URLContext) -> Swift.Bool
  func braze(_ braze: BrazeKit.Braze, noMatchingTriggerForEvent event: BrazeKit.Braze.TriggerEvent)
  func braze(_ braze: BrazeKit.Braze, sdkAuthenticationFailedWithError error: BrazeKit.Braze.SDKAuthenticationError)
}
extension BrazeKit.BrazeDelegate {
  public func braze(_ braze: BrazeKit.Braze, shouldOpenURL context: BrazeKit.Braze.URLContext) -> Swift.Bool
  public func braze(_ braze: BrazeKit.Braze, noMatchingTriggerForEvent event: BrazeKit.Braze.TriggerEvent)
  public func braze(_ braze: BrazeKit.Braze, sdkAuthenticationFailedWithError error: BrazeKit.Braze.SDKAuthenticationError)
}
@objc(BrazeInAppMessagePresenter) public protocol _OBJC_BrazeInAppMessagePresenter {
  @objc(presentMessage:) func present(message: BrazeKit.Braze.InAppMessageRaw)
}
public protocol BrazeInAppMessagePresenter {
  func present(message: BrazeKit.Braze.InAppMessage)
}
@objc public protocol BrazeInAppMessageWindowType {
}
@objc public protocol BrazeSDKAuthDelegate {
  @objc func braze(_ braze: BrazeKit.Braze, sdkAuthenticationFailedWithError error: BrazeKit.Braze.SDKAuthenticationError)
}
extension BrazeKit.BrazeSDKAuthDelegate {
  public func braze(_ braze: BrazeKit.Braze, sdkAuthenticationFailedWithError error: BrazeKit.Braze.SDKAuthenticationError)
}
@objc(BRZChannel) public enum _OBJC_BRZChannel : Swift.Int {
  case notification
  case inAppMessage
  case newsFeed
  case contentCard
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension BrazeKit.Braze.URLContext {
  @available(swift, obsoleted: 0.0.1)
  @objc(channel) dynamic public var _objc_channel: BrazeKit._OBJC_BRZChannel {
    @objc get
  }
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override dynamic public var hash: Swift.Int {
    @objc get
  }
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZCancellable) final public class Cancellable : ObjectiveC.NSObject {
    @objc deinit
    @objc final public func cancel()
    @objc public static let empty: BrazeKit.Braze.Cancellable
  }
}
extension BrazeKit.Braze {
  public enum Channel : Swift.String, Swift.Codable {
    case notification
    case inAppMessage
    case contentCard
    case newsFeed
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.Configuration {
  @available(swift, obsoleted: 0.0.1)
  @objc(devicePropertyAllowList) dynamic public var _objc_devicePropertyAllowList: [BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty] {
    @objc get
    @objc set
  }
  @_hasMissingDesignatedInitializers @objc(BRZDeviceProperty) final public class _OBJC_BRZDeviceProperty : ObjectiveC.NSObject {
    @objc public static let model: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let osVersion: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let resolution: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let timeZone: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let locale: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let carrier: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let pushEnabled: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc public static let pushAuthStatus: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @available(*, deprecated, message: "Push display options are no longer supported. Providing this value will have no effect.")
    @objc public static let pushDisplayOptions: BrazeKit.Braze.Configuration._OBJC_BRZDeviceProperty
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration.Api {
  @available(swift, obsoleted: 0.0.1)
  @objc(requestPolicy) dynamic public var _objc_requestPolicy: BrazeKit._OBJC_BRZRequestPolicy {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(sdkFlavor) dynamic public var _objc_sdkFlavor: BrazeKit._OBJC_BRZSDKFlavor {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(sdkMetadata) dynamic public var _objc_sdkMetadata: [BrazeKit._OBJC_BRZSDKMetadata] {
    @objc get
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(addSDKMetadata:) dynamic public func _objc_addSDKMetadata(_ sdkMetadata: [BrazeKit._OBJC_BRZSDKMetadata])
  @available(swift, obsoleted: 0.0.1)
  @objc(trackingPropertyAllowList) dynamic public var _objc_trackingPropertyAllowList: Swift.Set<BrazeKit._OBJC_BRZTrackingProperty> {
    @objc get
    @objc set(newList)
  }
}
@objc(BRZRequestPolicy) public enum _OBJC_BRZRequestPolicy : Swift.Int {
  case automatic
  case manual
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc(BRZSDKFlavor) public enum _OBJC_BRZSDKFlavor : Swift.Int {
  case vanilla
  case unity
  case react
  case cordova
  case xamarin
  case flutter
  case segment
  case mparticle
  case tealium
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc(BRZSDKMetadata) final public class _OBJC_BRZSDKMetadata : ObjectiveC.NSObject {
  @objc public static let adjust: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let airbridge: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let appsflyer: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let bluedot: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let branch: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let cordova: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let carthage: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let cocoapods: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let cordovapm: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let expo: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let foursquare: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let flutter: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let googletagmanager: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let gimbal: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let gradle: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let ionic: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let kochava: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let manual: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let maccatalyst: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let mparticle: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let nativescript: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let npm: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let nuget: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let pub: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let radar: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let reactnative: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let reactnativenewarch: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let segment: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let singular: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let swiftpm: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let tealium: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let unreal: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let unitypm: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let unity: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let vizbee: BrazeKit._OBJC_BRZSDKMetadata
  @objc public static let xamarin: BrazeKit._OBJC_BRZSDKMetadata
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @objc(BRZConfiguration) public class Configuration : ObjectiveC.NSObject {
    @objc public var api: BrazeKit.Braze.Configuration.Api
    @objc public var push: BrazeKit.Braze.Configuration.Push
    @objc public var location: BrazeKit.Braze.Configuration.Location
    @objc public var logger: BrazeKit.Braze.Configuration.Logger
    @objc public var sessionTimeout: Swift.Double
    @objc public var triggerMinimumTimeInterval: Swift.Double
    public var devicePropertyAllowList: Swift.Set<BrazeKit.Braze.Configuration.DeviceProperty>
    @objc public var useUUIDAsDeviceId: Swift.Bool
    @objc public var forwardUniversalLinks: Swift.Bool
    @objc public var optInWhenPushAuthorized: Swift.Bool
    @objc public var tvOSPersistedSizeLimit: Swift.UInt64
    @objc public var ephemeralEvents: [Swift.String]
    @objc public init(apiKey: Swift.String, endpoint: Swift.String)
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration {
  @_inheritsConvenienceInitializers @objc(BRZConfigurationApi) public class Api : ObjectiveC.NSObject {
    @objc public var key: Swift.String?
    @objc public var endpoint: Swift.String?
    public var requestPolicy: BrazeKit.Braze.Configuration.Api.RequestPolicy
    @objc public var flushInterval: Swift.Double
    @objc public var sdkAuthentication: Swift.Bool
    public var sdkFlavor: BrazeKit.Braze.Configuration.Api.SDKFlavor
    public var sdkMetadata: Swift.Set<BrazeKit.Braze.Configuration.Api.SDKMetadata> {
      get
    }
    public var trackingPropertyAllowList: Swift.Set<BrazeKit.Braze.Configuration.TrackingProperty>
    public func addSDKMetadata(_ sdkMetadata: [BrazeKit.Braze.Configuration.Api.SDKMetadata])
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration.Api {
  public enum RequestPolicy : Swift.String, Swift.CaseIterable, Swift.Codable {
    case automatic
    case manual
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.Configuration.Api.RequestPolicy]
    public typealias RawValue = Swift.String
    public static var allCases: [BrazeKit.Braze.Configuration.Api.RequestPolicy] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum SDKFlavor : Swift.String, Swift.CaseIterable, Swift.Codable {
    case vanilla
    case unity
    case react
    case cordova
    case xamarin
    case flutter
    case segment
    case mparticle
    case tealium
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.Configuration.Api.SDKFlavor]
    public typealias RawValue = Swift.String
    public static var allCases: [BrazeKit.Braze.Configuration.Api.SDKFlavor] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum SDKMetadata : Swift.String, Swift.CaseIterable, Swift.Codable {
    case adjust
    case airbridge
    case appsflyer
    case bluedot
    case branch
    case cordova
    case carthage
    case cocoapods
    case cordovapm
    case expo
    case foursquare
    case flutter
    case googletagmanager
    case gimbal
    case gradle
    case ionic
    case kochava
    case manual
    case maccatalyst
    case mparticle
    case nativescript
    case npm
    case nuget
    case pub
    case radar
    case reactnative
    case reactnativenewarch
    case segment
    case singular
    case swiftpm
    case tealium
    case unreal
    case unitypm
    case unity
    case vizbee
    case xamarin
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.Configuration.Api.SDKMetadata]
    public typealias RawValue = Swift.String
    public static var allCases: [BrazeKit.Braze.Configuration.Api.SDKMetadata] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.Configuration {
  public enum DeviceProperty : Swift.String, Swift.CaseIterable, Swift.Codable {
    case model
    case osVersion
    case resolution
    case timeZone
    case locale
    case carrier
    case pushEnabled
    case pushAuthStatus
    @available(*, deprecated, message: "Push display options are no longer supported. Providing this value will have no effect.")
    case pushDisplayOptions
    public static var allCases: [BrazeKit.Braze.Configuration.DeviceProperty]
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.Configuration.DeviceProperty]
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.Configuration {
  @_inheritsConvenienceInitializers @objc(BRZConfigurationLocation) public class Location : ObjectiveC.NSObject {
    @objc public var automaticLocationCollection: Swift.Bool
    @objc public var geofencesEnabled: Swift.Bool
    @objc public var automaticGeofenceRequests: Swift.Bool
    @objc public var allowBackgroundGeofenceUpdates: Swift.Bool
    @objc public var distanceFilter: Swift.Double
    @objc public var brazeLocationProvider: Swift.AnyObject?
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration {
  @_inheritsConvenienceInitializers @objc(BRZConfigurationLogger) public class Logger : ObjectiveC.NSObject {
    @objc public var level: BrazeKit.Braze.Configuration.Logger.Level
    @objc public var signposts: Swift.Bool
    @objc public var print: ((_ message: Swift.String, _ level: BrazeKit.Braze.Configuration.Logger.Level) -> Swift.Bool)?
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration.Logger {
  @objc(BRZLoggerLevel) public enum Level : Swift.UInt8, Swift.CaseIterable, Swift.Codable {
    case debug
    case info
    case error
    case disabled = 255
    public init?(rawValue: Swift.UInt8)
    public typealias AllCases = [BrazeKit.Braze.Configuration.Logger.Level]
    public typealias RawValue = Swift.UInt8
    public static var allCases: [BrazeKit.Braze.Configuration.Logger.Level] {
      get
    }
    public var rawValue: Swift.UInt8 {
      get
    }
  }
}
extension BrazeKit.Braze.Configuration {
  @_inheritsConvenienceInitializers @objc(BRZConfigurationPush) public class Push : ObjectiveC.NSObject {
    @objc public var appGroup: Swift.String?
    @objc public var automation: BrazeKit.Braze.Configuration.Push.Automation
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration.Push {
  @objc(BRZConfigurationPushAutomation) public class Automation : ObjectiveC.NSObject, Swift.ExpressibleByBooleanLiteral {
    @objc public static let defaultForegroundPresentationOptions: UserNotifications.UNNotificationPresentationOptions
    @objc public var automaticSetup: Swift.Bool
    @objc public var requestAuthorizationAtLaunch: Swift.Bool
    @objc public var authorizationOptions: UserNotifications.UNAuthorizationOptions
    @objc public var foregroundPresentationOptions: UserNotifications.UNNotificationPresentationOptions
    @objc public var setNotificationCategories: Swift.Bool
    @objc public var registerDeviceToken: Swift.Bool
    @objc public var handleBackgroundNotification: Swift.Bool
    @objc public var handleNotificationResponse: Swift.Bool
    @objc public var willPresentNotification: Swift.Bool
    @objc public init(automaticSetup: Swift.Bool = false, requestAuthorizationAtLaunch: Swift.Bool = false, authorizationOptions: UserNotifications.UNAuthorizationOptions = [.badge, .sound, .alert], foregroundPresentationOptions: UserNotifications.UNNotificationPresentationOptions = Automation
        .defaultForegroundPresentationOptions, setNotificationCategories: Swift.Bool = false, registerDeviceToken: Swift.Bool = false, handleBackgroundNotification: Swift.Bool = false, handleNotificationResponse: Swift.Bool = false, willPresentNotification: Swift.Bool = false)
    convenience required public init(booleanLiteral value: Swift.BooleanLiteralType)
    @available(swift, obsoleted: 0.0.1)
    @objc(initEnablingAllAutomations:) convenience public init(enablingAllAutomations enabled: Swift.Bool)
    public typealias BooleanLiteralType = Swift.BooleanLiteralType
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers @objc(BRZTrackingProperty) final public class _OBJC_BRZTrackingProperty : ObjectiveC.NSObject {
  @objc public static let deviceData: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let firstName: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let lastName: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let email: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let dateOfBirth: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let country: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let language: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let homeCity: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let gender: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let phoneNumber: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let emailSubscriptionState: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let notificationSubscriptionState: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let attributionData: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let pushToken: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let pushToStartTokens: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static func customAttribute(attributes: Swift.Set<Swift.String>) -> BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let allCustomAttributes: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let analyticsEvents: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let purchases: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static func customEvent(events: Swift.Set<Swift.String>) -> BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let allCustomEvents: BrazeKit._OBJC_BRZTrackingProperty
  @objc public static let everything: BrazeKit._OBJC_BRZTrackingProperty
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension BrazeKit.Braze.Configuration {
  public enum TrackingProperty : Swift.Hashable {
    case deviceData
    case firstName, lastName, email, dateOfBirth, country, language, homeCity, gender, phoneNumber, emailSubscriptionState, notificationSubscriptionState, attributionData, pushToken, pushToStartTokens
    case customAttribute(Swift.Set<Swift.String>)
    case allCustomAttributes
    case analyticsEvents
    case purchases
    case customEvent(Swift.Set<Swift.String>)
    case allCustomEvents
    case everything
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.Configuration.TrackingProperty, b: BrazeKit.Braze.Configuration.TrackingProperty) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension BrazeKit.Braze {
  indirect public enum ContentCard : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable {
    case classic(BrazeKit.Braze.ContentCard.Classic)
    case classicImage(BrazeKit.Braze.ContentCard.ClassicImage)
    case imageOnly(BrazeKit.Braze.ContentCard.ImageOnly)
    case captionedImage(BrazeKit.Braze.ContentCard.CaptionedImage)
    case control(BrazeKit.Braze.ContentCard.Control)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard, b: BrazeKit.Braze.ContentCard) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.ContentCard {
  public var classic: BrazeKit.Braze.ContentCard.Classic? {
    get
    set
  }
  public var classicImage: BrazeKit.Braze.ContentCard.ClassicImage? {
    get
    set
  }
  public var imageOnly: BrazeKit.Braze.ContentCard.ImageOnly? {
    get
    set
  }
  public var captionedImage: BrazeKit.Braze.ContentCard.CaptionedImage? {
    get
    set
  }
  public var control: BrazeKit.Braze.ContentCard.Control? {
    get
    set
  }
}
extension BrazeKit.Braze.ContentCard {
  public var imageURL: Foundation.URL? {
    get
  }
}
extension BrazeKit.Braze.ContentCardRaw.Context {
  @objc convenience dynamic public init(logImpression: @escaping () -> Swift.Void, logClick: @escaping () -> Swift.Void, processClickAction: @escaping (_ url: Foundation.URL, _ useWebView: Swift.Bool) -> Swift.Void, logDismissed: @escaping () -> Swift.Void, logError: @escaping (any Swift.Error) -> Swift.Void, loadImage: ((@escaping (Foundation.URL?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable)?)
  @objc convenience dynamic public init?(cardRaw: BrazeKit.Braze.ContentCardRaw, using braze: BrazeKit.Braze)
  @available(swift, obsoleted: 0.0.1)
  @objc(loadImageWithCompletion:) final public func _objc_loadImage(completion: @escaping (Foundation.URL?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze.ContentCard {
  public typealias Context = BrazeKit.Braze.ContentCardRaw.Context
}
extension BrazeKit.Braze.ContentCardRaw {
  @objc(BRZContentCardContext) final public class Context : ObjectiveC.NSObject {
    public init(logImpression: @escaping () -> Swift.Void, logClick: @escaping () -> Swift.Void, processClickAction: @escaping (BrazeKit.Braze.ContentCard.ClickAction) -> Swift.Void, logDismissed: @escaping () -> Swift.Void, logError: @escaping (any Swift.Error) -> Swift.Void, loadImage: ((@escaping (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable)?)
    convenience public init(card: BrazeKit.Braze.ContentCard, using braze: BrazeKit.Braze)
    @objc final public func logImpression()
    @objc final public func logClick()
    final public func processClickAction(_ clickAction: BrazeKit.Braze.ContentCard.ClickAction)
    @objc(processClickActionWithURL:useWebView:) final public func processClickAction(url: Foundation.URL, useWebView: Swift.Bool)
    @objc final public func logDismissed()
    @objc final public func logError(_ error: any Swift.Error)
    final public let loadImage: ((_ completion: @escaping (Swift.Result<Foundation.URL, any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable)?
    @objc deinit
  }
}
extension BrazeKit.Braze.ContentCard {
  public struct Data : Swift.Hashable, Swift.Codable {
    public var id: Swift.String
    public var clickAction: BrazeKit.Braze.ContentCard.ClickAction?
    public var viewed: Swift.Bool
    public var dismissible: Swift.Bool
    public var removed: Swift.Bool
    public var pinned: Swift.Bool
    public var clicked: Swift.Bool
    public var test: Swift.Bool
    public var createdAt: Foundation.TimeInterval
    public var expiresAt: Foundation.TimeInterval
    public var extras: [Swift.String : Any] {
      get
      set
    }
    public var context: BrazeKit.Braze.ContentCard.Context?
    public init(id: Swift.String = UUID().uuidString, clickAction: BrazeKit.Braze.ContentCard.ClickAction? = nil, viewed: Swift.Bool = false, dismissible: Swift.Bool = false, removed: Swift.Bool = false, pinned: Swift.Bool = false, clicked: Swift.Bool = false, test: Swift.Bool = false, createdAt: Foundation.TimeInterval = 0, expiresAt: Foundation.TimeInterval = -1, extras: [Swift.String : Any] = [:])
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.Data, b: BrazeKit.Braze.ContentCard.Data) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@dynamicMemberLookup public protocol BrazeContentCardDataLookup {
  var data: BrazeKit.Braze.ContentCard.Data { get set }
  subscript<Value>(dynamicMember keyPath: Swift.WritableKeyPath<BrazeKit.Braze.ContentCard.Data, Value>) -> Value { get set }
}
extension BrazeKit.BrazeContentCardDataLookup {
  public subscript<Value>(dynamicMember keyPath: Swift.WritableKeyPath<BrazeKit.Braze.ContentCard.Data, Value>) -> Value {
    get
    set
  }
}
extension BrazeKit.Braze.ContentCard {
  public var data: BrazeKit.Braze.ContentCard.Data {
    get
    set
  }
}
extension BrazeKit.Braze.ContentCard {
  public var title: Swift.String? {
    get
    set
  }
  public var description: Swift.String? {
    get
    set
  }
  public var domain: Swift.String? {
    get
    set
  }
}
extension BrazeKit.Braze.ContentCard {
  public func json() -> Foundation.Data?
  public static func decoding(json: Foundation.Data) -> BrazeKit.Braze.ContentCard?
}
extension BrazeKit.Braze.ContentCard {
  public func logImpression(using braze: BrazeKit.Braze)
  public func logClick(using braze: BrazeKit.Braze)
  public func logDismissed(using braze: BrazeKit.Braze)
}
extension BrazeKit.Braze.ContentCardRaw {
  @available(swift, obsoleted: 0.0.1)
  @objc(type) dynamic public var _objc_type: BrazeKit.Braze.ContentCardRaw._OBJC_BRZContentCardRawType {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(imageAspectRatio) dynamic public var _objc_imageAspectRatio: Swift.Double {
    @objc get
    @objc set
  }
}
extension BrazeKit.Braze.ContentCardRaw {
  @objc dynamic public func logImpression(using braze: BrazeKit.Braze)
  @objc dynamic public func logClick(using braze: BrazeKit.Braze)
  @objc dynamic public func logDismissed(using braze: BrazeKit.Braze)
}
extension BrazeKit.Braze.ContentCardRaw {
  @objc(BRZContentCardRawType) public enum _OBJC_BRZContentCardRawType : Swift.Int {
    case classic
    case imageOnly
    case captionedImage
    case control
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @objc(BRZContentCardRaw) public class ContentCardRaw : ObjectiveC.NSObject, Swift.Codable {
    @objc(identifier) public var id: Swift.String
    public var type: BrazeKit.Braze.ContentCardRaw.CardType
    @objc public var image: Foundation.URL?
    public var imageAspectRatio: Swift.Double?
    @objc public var title: Swift.String?
    @objc public var cardDescription: Swift.String?
    @objc public var domain: Swift.String?
    @objc public var url: Foundation.URL?
    @objc public var useWebView: Swift.Bool
    @objc public var extras: [Swift.String : Any] {
      @objc get
      @objc set
    }
    @objc public var viewed: Swift.Bool
    @objc public var dismissible: Swift.Bool
    @objc public var removed: Swift.Bool
    @objc public var pinned: Swift.Bool
    @objc public var clicked: Swift.Bool
    @objc public var test: Swift.Bool
    @objc public var createdAt: Swift.Double
    @objc public var expiresAt: Swift.Double
    @objc public var context: BrazeKit.Braze.ContentCard.Context?
    @objc public func json() -> Foundation.Data?
    @objc public static func decoding(json: Foundation.Data) -> Self?
    @objc override dynamic public init()
    public init(_ card: BrazeKit.Braze.ContentCard)
    @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override dynamic public var hash: Swift.Int {
      @objc get
    }
    @objc public static func from(json: Foundation.Data) -> BrazeKit.Braze.ContentCardRaw?
    @objc deinit
    public func encode(to encoder: any Swift.Encoder) throws
    required public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.ContentCardRaw {
  public enum CardType : Swift.String, Swift.Codable {
    case classic
    case imageOnly
    case captionedImage
    case control
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.ContentCard {
  public init(_ card: BrazeKit.Braze.ContentCardRaw) throws
}
extension BrazeKit.Braze.ContentCard {
  public struct Classic : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.ContentCard.Data
    public var title: Swift.String
    public var description: Swift.String
    public var domain: Swift.String?
    public init(data: BrazeKit.Braze.ContentCard.Data = .init(), title: Swift.String, description: Swift.String, domain: Swift.String? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.Classic, b: BrazeKit.Braze.ContentCard.Classic) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ClassicImage : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.ContentCard.Data
    public var image: Foundation.URL
    public var title: Swift.String
    public var description: Swift.String
    public var domain: Swift.String?
    public init(data: BrazeKit.Braze.ContentCard.Data = .init(), image: Foundation.URL, title: Swift.String, description: Swift.String, domain: Swift.String? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.ClassicImage, b: BrazeKit.Braze.ContentCard.ClassicImage) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ImageOnly : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.ContentCard.Data
    public var image: Foundation.URL
    public var imageAspectRatio: Swift.Double?
    public init(data: BrazeKit.Braze.ContentCard.Data = .init(), image: Foundation.URL, imageAspectRatio: Swift.Double? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.ImageOnly, b: BrazeKit.Braze.ContentCard.ImageOnly) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct CaptionedImage : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.ContentCard.Data
    public var image: Foundation.URL
    public var imageAspectRatio: Swift.Double?
    public var title: Swift.String
    public var description: Swift.String
    public var domain: Swift.String?
    public init(data: BrazeKit.Braze.ContentCard.Data = .init(), image: Foundation.URL, imageAspectRatio: Swift.Double? = nil, title: Swift.String, description: Swift.String, domain: Swift.String? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.CaptionedImage, b: BrazeKit.Braze.ContentCard.CaptionedImage) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Control : BrazeKit.BrazeContentCardDataLookup, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.ContentCard.Data
    public init(data: BrazeKit.Braze.ContentCard.Data = .init())
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.Control, b: BrazeKit.Braze.ContentCard.Control) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.ContentCard {
  public enum ClickAction : Swift.Hashable, Swift.Codable {
    case url(Foundation.URL, useWebView: Swift.Bool)
    public var url: Foundation.URL? {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ContentCard.ClickAction, b: BrazeKit.Braze.ContentCard.ClickAction) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.ContentCards {
  @available(swift, obsoleted: 0.0.1)
  @objc(cards) final public var _objc_cards: [BrazeKit.Braze.ContentCardRaw] {
    @objc get
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(unviewedCards) final public var _objc_unviewedCards: [BrazeKit.Braze.ContentCardRaw] {
    @objc get
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(requestRefresh) final public func _objc_requestRefresh()
  @available(swift, obsoleted: 0.0.1)
  @objc(requestRefreshWithCompletion:) final public func _objc_requestRefresh(_ completion: @escaping ([BrazeKit.Braze.ContentCardRaw]?, (any Swift.Error)?) -> Swift.Void)
  @available(swift, obsoleted: 0.0.1)
  @objc(subscribeToUpdates:) final public func _objc_subscribeToUpdates(_ update: @escaping ([BrazeKit.Braze.ContentCardRaw]) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZContentCards) final public class ContentCards : ObjectiveC.NSObject {
    final public var cards: [BrazeKit.Braze.ContentCard] {
      get
    }
    final public var unviewedCards: [BrazeKit.Braze.ContentCard] {
      get
    }
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    final public var cardsStream: _Concurrency.AsyncStream<[BrazeKit.Braze.ContentCard]> {
      get
    }
    @objc final public var lastUpdate: Foundation.Date? {
      @objc get
    }
    final public func requestRefresh(_ completion: ((Swift.Result<[BrazeKit.Braze.ContentCard], any Swift.Error>) -> Swift.Void)? = nil)
    #if compiler(>=5.3) && $AsyncAwait
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    @discardableResult
    final public func requestRefresh() async throws -> [BrazeKit.Braze.ContentCard]
    #endif
    final public func subscribeToUpdates(_ update: @escaping ([BrazeKit.Braze.ContentCard]) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    @objc deinit
  }
}
extension BrazeKit.Braze.Configuration.Api {
  @available(*, deprecated, renamed: "SDKMetadata")
  public typealias SdkMetadata = BrazeKit.Braze.Configuration.Api.SDKMetadata
  @available(*, deprecated, renamed: "addSDKMetadata(_:)")
  public func addSdkMetadata(_ sdkMetadata: [BrazeKit.Braze.Configuration.Api.SDKMetadata])
}
extension BrazeKit.Braze.InAppMessage.Themes {
  @available(*, deprecated, renamed: "defaults")
  public static let `default`: BrazeKit.Braze.InAppMessage.Themes
}
extension BrazeKit.Braze.ContentCard.ClickAction {
  @available(*, deprecated, renamed: "url(_:useWebView:)")
  public static func uri(_ uri: Foundation.URL, useWebView: Swift.Bool) -> BrazeKit.Braze.ContentCard.ClickAction
  @available(*, deprecated, renamed: "url")
  public var uri: Foundation.URL? {
    get
  }
}
extension BrazeKit.Braze.InAppMessage.ClickAction {
  @available(*, deprecated, renamed: "url(_:useWebView:)")
  public static func uri(_ uri: Foundation.URL, useWebView: Swift.Bool) -> BrazeKit.Braze.InAppMessage.ClickAction
  @available(*, deprecated, renamed: "url")
  public var uri: Foundation.URL? {
    get
  }
}
extension BrazeKit.Braze.InAppMessage.ModalImage {
  @available(*, deprecated, renamed: "imageURL")
  public var imageUri: Foundation.URL {
    get
    set
  }
}
extension BrazeKit.Braze.InAppMessage.Full {
  @available(*, deprecated, renamed: "imageURL")
  public var imageUri: Foundation.URL {
    get
    set
  }
}
extension BrazeKit.Braze.InAppMessage.FullImage {
  @available(*, deprecated, renamed: "imageURL")
  public var imageUri: Foundation.URL {
    get
    set
  }
}
extension BrazeKit.Braze.Configuration.Api {
  @available(*, deprecated, renamed: "SDKFlavor")
  public typealias Flavor = BrazeKit.Braze.Configuration.Api.SDKFlavor
  @available(*, deprecated, renamed: "sdkFlavor")
  public var flavor: BrazeKit.Braze.Configuration.Api.SDKFlavor {
    get
    set
  }
}
extension BrazeKit.Braze {
  @available(*, deprecated, renamed: "deviceId")
  @objc(deviceIdOnQueue:completion:) final public func deviceId(queue: Dispatch.DispatchQueue = .main, completion: @escaping (Swift.String) -> Swift.Void)
  @available(*, deprecated, renamed: "deviceId")
  @available(swift, obsoleted: 0.0.1)
  @objc(deviceIdWithCompletion:) final public func _objc_deviceId(completion: @escaping (Swift.String) -> Swift.Void)
  #if compiler(>=5.3) && $AsyncAwait
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
  @available(*, deprecated, renamed: "deviceId")
  final public func deviceId() async -> Swift.String
  #endif
}
extension BrazeKit.Braze.User {
  @available(*, deprecated, renamed: "setCustomAttribute")
  final public func setCustomAttributeArray(key: Swift.String, array: [Swift.String]?, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  @available(*, deprecated, renamed: "addToCustomAttributeStringArray")
  final public func addToCustomAttributeArray(key: Swift.String, value: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  @available(*, deprecated, renamed: "removeFromCustomAttributeStringArray")
  final public func removeFromCustomAttributeArray(key: Swift.String, value: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
  @available(swift, obsoleted: 0.0.1)
  @available(*, deprecated, renamed: "addToCustomAttributeStringArrayWithKey")
  @objc(addToCustomAttributeArrayWithKey:value:) final public func _objc_addToCustomAttributeArray(key: Swift.String, value: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @available(*, deprecated, renamed: "removeFromCustomAttributeStringArrayWithKey")
  @objc(removeFromCustomAttributeArrayWithKey:value:) final public func _objc_removeFromCustomAttributeArray(key: Swift.String, value: Swift.String)
}
extension BrazeKit.Braze.Configuration.Location {
  @available(*, unavailable, renamed: "brazeLocationProvider")
  @objc dynamic public var brazeLocation: Swift.AnyObject? {
    @objc get
    @objc set
  }
}
public var overrideResourceBundle: Foundation.Bundle? {
  get
  set
}
extension BrazeKit.Braze {
  @available(*, deprecated, renamed: "Braze.Resources.acknowledgments")
  @objc public static var acknowledgments: [Swift.String : Foundation.URL]
  @available(*, deprecated, renamed: "Braze.Resources.license")
  @objc public static var license: Foundation.URL?
}
extension BrazeKit.Braze {
  public struct ErrorString : Swift.Error, Swift.Hashable {
    public init(_ error: any Swift.Error)
    public init(_ error: Swift.String)
    public var logDescription: Swift.String {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.ErrorString, b: BrazeKit.Braze.ErrorString) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension BrazeKit.Braze.FeatureFlag {
  @objc(numberPropertyForKey:) dynamic public func _objc_numberProperty(key: Swift.String) -> Foundation.NSNumber?
  @objc(boolPropertyForKey:) dynamic public func _objc_boolProperty(key: Swift.String) -> Foundation.NSNumber?
}
extension BrazeKit.Braze.FeatureFlag {
  @objc dynamic public func json() -> Foundation.Data?
  @objc public static func decoding(json: Foundation.Data) -> Self?
}
extension BrazeKit.Braze.FeatureFlags {
  @available(swift, obsoleted: 0.0.1)
  @objc(requestRefresh) final public func _objc_requestRefresh()
  @available(swift, obsoleted: 0.0.1)
  @objc(requestRefreshWithCompletion:) final public func _objc_requestRefresh(_ completion: @escaping ([BrazeKit.Braze.FeatureFlag]?, (any Swift.Error)?) -> Swift.Void)
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZFeatureFlags) final public class FeatureFlags : ObjectiveC.NSObject {
    @objc final public var featureFlags: [BrazeKit.Braze.FeatureFlag] {
      @objc get
    }
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    final public var featureFlagsStream: _Concurrency.AsyncStream<[BrazeKit.Braze.FeatureFlag]> {
      get
    }
    @objc final public func featureFlag(id: Swift.String) -> BrazeKit.Braze.FeatureFlag?
    final public func requestRefresh(_ completion: ((Swift.Result<[BrazeKit.Braze.FeatureFlag], any Swift.Error>) -> Swift.Void)? = nil)
    #if compiler(>=5.3) && $AsyncAwait
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    @discardableResult
    final public func requestRefresh() async throws -> [BrazeKit.Braze.FeatureFlag]
    #endif
    @objc final public func subscribeToUpdates(_ update: @escaping ([BrazeKit.Braze.FeatureFlag]) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    @objc final public func logFeatureFlagImpression(id: Swift.String)
    @objc deinit
  }
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(BRZFeatureFlag) public class FeatureFlag : ObjectiveC.NSObject, Swift.Codable {
    @objc(identifier) public var id: Swift.String
    @objc public var enabled: Swift.Bool
    @objc public var properties: [Swift.String : Any] {
      @objc get
      @objc set
    }
    @objc public var flagTrackingString: Swift.String?
    @objc(stringPropertyForKey:) public func stringProperty(key: Swift.String) -> Swift.String?
    public func numberProperty(key: Swift.String) -> Swift.Double?
    public func boolProperty(key: Swift.String) -> Swift.Bool?
    @objc override dynamic public init()
    @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override dynamic public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
    public func encode(to encoder: any Swift.Encoder) throws
    required public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze {
  indirect public enum InAppMessage : BrazeKit.BrazeInAppMessageDataLookup, Swift.Hashable, Swift.Codable {
    case slideup(BrazeKit.Braze.InAppMessage.Slideup)
    case modal(BrazeKit.Braze.InAppMessage.Modal)
    case modalImage(BrazeKit.Braze.InAppMessage.ModalImage)
    case full(BrazeKit.Braze.InAppMessage.Full)
    case fullImage(BrazeKit.Braze.InAppMessage.FullImage)
    case html(BrazeKit.Braze.InAppMessage.Html)
    case control(BrazeKit.Braze.InAppMessage.Control)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage, b: BrazeKit.Braze.InAppMessage) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessage {
  public var slideup: BrazeKit.Braze.InAppMessage.Slideup? {
    get
    set
  }
  public var modal: BrazeKit.Braze.InAppMessage.Modal? {
    get
    set
  }
  public var modalImage: BrazeKit.Braze.InAppMessage.ModalImage? {
    get
    set
  }
  public var full: BrazeKit.Braze.InAppMessage.Full? {
    get
    set
  }
  public var fullImage: BrazeKit.Braze.InAppMessage.FullImage? {
    get
    set
  }
  public var html: BrazeKit.Braze.InAppMessage.Html? {
    get
    set
  }
  public var control: BrazeKit.Braze.InAppMessage.Control? {
    get
    set
  }
}
extension BrazeKit.Braze.InAppMessageRaw.Context {
  @objc convenience dynamic public init(logImpression: @escaping () -> Swift.Void, logClick: @escaping (_ buttonId: Swift.String?) -> Swift.Void, processClickAction: @escaping (BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction, Foundation.URL?, Any?) -> Swift.Void, logError: @escaping (any Swift.Error) -> Swift.Void, braze: @escaping () -> Any?, getLocalAssets: @escaping ([Foundation.URL], Foundation.URL, @escaping ([Foundation.URL : Foundation.URL]?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable, withLocalAssets: @escaping (BrazeKit.Braze.InAppMessageRaw, Foundation.URL, @escaping (BrazeKit.Braze.InAppMessageRaw?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable, multipleLogClickEnabled: Swift.Bool)
  @objc convenience dynamic public init?(messageRaw: BrazeKit.Braze.InAppMessageRaw, using braze: BrazeKit.Braze)
  @available(swift, obsoleted: 0.0.1)
  @objc(logClick) final public func _objc_logClick()
  @available(swift, obsoleted: 0.0.1)
  @objc(logClickWithButtonId:) final public func _objc_logClick(buttonId: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(processClickAction:url:useWebView:) final public func _objc_processClickAction(_ clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction, url: Foundation.URL?, useWebView: Swift.Bool)
  @available(swift, obsoleted: 0.0.1)
  @objc(processClickAction:url:useWebView:target:) final public func _objc_processClickAction(_ clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction, url: Foundation.URL?, useWebView: Swift.Bool, target: Any? = nil)
  @available(swift, obsoleted: 0.0.1)
  @objc(getLocalAssets:destinationURL:completionHandler:) final public func _objc_getLocalAssets(urls: [Foundation.URL], destinationURL: Foundation.URL, completionHandler: @escaping ([Foundation.URL : Foundation.URL]?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable
  @available(swift, obsoleted: 0.0.1)
  @objc(withLocalAssets:destinationURL:completionHandler:) final public func _objc_withLocalAssets(message: BrazeKit.Braze.InAppMessageRaw, destinationURL: Foundation.URL, completionHandler: @escaping (BrazeKit.Braze.InAppMessageRaw?, (any Swift.Error)?) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze.InAppMessage {
  public typealias Context = BrazeKit.Braze.InAppMessageRaw.Context
}
extension BrazeKit.Braze.InAppMessageRaw {
  @objc(BRZInAppMessageContext) final public class Context : ObjectiveC.NSObject {
    public enum Error : Swift.Error, Swift.Hashable {
      case noLogImpression
      case extraLogImpression
      case extraLogClick
      case extraProcessClickAction
      case processClickActionMissingUri
      public static func == (a: BrazeKit.Braze.InAppMessageRaw.Context.Error, b: BrazeKit.Braze.InAppMessageRaw.Context.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @objc final public var valid: Swift.Bool {
      @objc get
    }
    @objc final public var braze: Any? {
      @objc get
    }
    public init(logImpression: @escaping () -> Swift.Void, logClick: @escaping (_ buttonId: Swift.String?) -> Swift.Void, processClickAction: @escaping (BrazeKit.Braze.InAppMessage.ClickAction, Any?) -> Swift.Void, logError: @escaping (any Swift.Error) -> Swift.Void, braze: @escaping () -> Any?, getLocalAssets: @escaping ([Foundation.URL], Foundation.URL, @escaping ((Swift.Result<[Foundation.URL : Foundation.URL], any Swift.Error>) -> Swift.Void)) -> BrazeKit.Braze.Cancellable, withLocalAssets: @escaping (BrazeKit.Braze.InAppMessage, Foundation.URL, @escaping (Swift.Result<BrazeKit.Braze.InAppMessage, any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable, multipleLogClickEnabled: Swift.Bool)
    convenience public init(message: BrazeKit.Braze.InAppMessage, using braze: BrazeKit.Braze)
    @objc final public func logImpression()
    final public func logClick(buttonId: Swift.String? = nil)
    final public func processClickAction(_ clickAction: BrazeKit.Braze.InAppMessage.ClickAction, target: Any? = nil)
    final public func processClickAction(_ clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction, url: Foundation.URL?, useWebView: Swift.Bool, target: Any? = nil)
    @objc final public func logError(_ error: any Swift.Error)
    @objc(logErrorFlattened:) final public func logError(flattened error: Swift.String)
    final public func getLocalAssets(urls: [Foundation.URL], destinationURL: Foundation.URL, completionHandler: @escaping (Swift.Result<[Foundation.URL : Foundation.URL], any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    final public func withLocalAssets(message: BrazeKit.Braze.InAppMessage, destinationURL: Foundation.URL, completionHandler: @escaping (Swift.Result<BrazeKit.Braze.InAppMessage, any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    @objc final public func discard()
    @objc deinit
  }
}
extension BrazeKit.Braze.InAppMessage {
  public struct Data : Swift.Hashable, Swift.Codable {
    public var id: Swift.String?
    public var clickAction: BrazeKit.Braze.InAppMessage.ClickAction
    public var messageClose: BrazeKit.Braze.InAppMessage.MessageClose
    public var orientation: BrazeKit.Braze.InAppMessage.Orientation
    public var animateIn: Swift.Bool
    public var animateOut: Swift.Bool
    public var isTestSend: Swift.Bool {
      get
    }
    public var extras: [Swift.String : Any] {
      get
      set
    }
    public var messageExtras: Swift.String?
    public var context: BrazeKit.Braze.InAppMessage.Context?
    public init(clickAction: BrazeKit.Braze.InAppMessage.ClickAction = .none, messageClose: BrazeKit.Braze.InAppMessage.MessageClose = .userInteraction, orientation: BrazeKit.Braze.InAppMessage.Orientation = .any, animateIn: Swift.Bool = true, animateOut: Swift.Bool = true, extras: [Swift.String : Any] = [:], messageExtras: Swift.String? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Data, b: BrazeKit.Braze.InAppMessage.Data) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
@dynamicMemberLookup public protocol BrazeInAppMessageDataLookup {
  var data: BrazeKit.Braze.InAppMessage.Data { get set }
  subscript<Value>(dynamicMember keyPath: Swift.WritableKeyPath<BrazeKit.Braze.InAppMessage.Data, Value>) -> Value { get set }
}
extension BrazeKit.BrazeInAppMessageDataLookup {
  public subscript<Value>(dynamicMember keyPath: Swift.WritableKeyPath<BrazeKit.Braze.InAppMessage.Data, Value>) -> Value {
    get
    set
  }
}
extension BrazeKit.Braze.InAppMessage {
  public var data: BrazeKit.Braze.InAppMessage.Data {
    get
    set
  }
  public var multipleLogClickEnabled: Swift.Bool {
    get
  }
}
extension BrazeKit.Braze.InAppMessage {
  public func json() -> Foundation.Data?
  public static func decoding(json: Foundation.Data) -> BrazeKit.Braze.InAppMessage?
}
extension BrazeKit.Braze.InAppMessage {
  public func logImpression(using braze: BrazeKit.Braze)
  public func logClick(buttonId: Swift.String?, using braze: BrazeKit.Braze)
  public func getLocalAssets(using braze: BrazeKit.Braze, urls: [Foundation.URL], destinationURL: Foundation.URL, completionHandler: @escaping (Swift.Result<[Foundation.URL : Foundation.URL], any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable
  public func withLocalAssets(using braze: BrazeKit.Braze, destinationURL: Foundation.URL, completionHandler: @escaping (Swift.Result<BrazeKit.Braze.InAppMessage, any Swift.Error>) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze.InAppMessage {
  public func isApproximatelyEqual(to message: BrazeKit.Braze.InAppMessage) -> Swift.Bool
}
extension BrazeKit.Braze.InAppMessageRaw {
  @available(swift, obsoleted: 0.0.1)
  @objc(_compat_hideChevron) dynamic public var _compat_hideChevron: Swift.Bool {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(_compat_overrideUserInterfaceStyle) dynamic public var _compat_overrideUserInterfaceStyle: Swift.Int {
    @objc get
    @objc set
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  @available(swift, obsoleted: 0.0.1)
  @objc(type) dynamic public var _objc_type: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawType {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(clickAction) dynamic public var _objc_clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(messageClose) dynamic public var _objc_messageClose: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClose {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(orientation) dynamic public var _objc_orientation: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawOrientation {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(messageTextAlignment) dynamic public var _objc_messageTextAlignment: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawTextAlignment {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(headerTextAlignment) dynamic public var _objc_headerTextAlignment: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawTextAlignment {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(duration) dynamic public var _objc_duration: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(imageStyle) dynamic public var _objc_imageStyle: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawImageStyle {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(slideFrom) dynamic public var _objc_slideFrom: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawSlideFrom {
    @objc get
    @objc set
  }
}
extension BrazeKit.Braze.InAppMessageRaw.Button {
  @available(swift, obsoleted: 0.0.1)
  @objc(clickAction) dynamic public var _objc_clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc convenience dynamic public init(id: Swift.Int, text: Swift.String, clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction, url: Foundation.URL?, useWebView: Swift.Bool)
  @available(swift, obsoleted: 0.0.1)
  @objc convenience dynamic public init(id: Swift.Int, text: Swift.String, clickAction: BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction, url: Foundation.URL?, useWebView: Swift.Bool, textColor: BrazeKit.Braze.InAppMessageRaw.Color, backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color, borderColor: BrazeKit.Braze.InAppMessageRaw.Color)
}
extension BrazeKit.Braze.InAppMessageRaw {
  @objc dynamic public func logImpression(using braze: BrazeKit.Braze)
  @objc dynamic public func logClick(buttonId: Swift.String?, using braze: BrazeKit.Braze)
}
extension BrazeKit.Braze.InAppMessageRaw {
  @objc(BRZInAppMessageRawType) public enum _OBJC_BRZInAppMessageRawType : Swift.Int {
    case slideup
    case modal
    case full
    case htmlFull
    case html
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawClickAction) public enum _OBJC_BRZInAppMessageRawClickAction : Swift.Int {
    case none
    case newsFeed
    @objc(BRZInAppMessageRawClickActionURL) case url
    public init(_ clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction)
    public var clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction {
      get
    }
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawClose) public enum _OBJC_BRZInAppMessageRawClose : Swift.Int {
    case autoDismiss
    case swipe
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawOrientation) public enum _OBJC_BRZInAppMessageRawOrientation : Swift.Int {
    case any
    case portrait
    case landscape
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawTextAlignment) public enum _OBJC_BRZInAppMessageRawTextAlignment : Swift.Int {
    case start
    case center
    case end
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawImageStyle) public enum _OBJC_BRZInAppMessageRawImageStyle : Swift.Int {
    case graphic
    case top
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc(BRZInAppMessageRawSlideFrom) public enum _OBJC_BRZInAppMessageRawSlideFrom : Swift.Int {
    case top
    case bottom
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @objc(BRZInAppMessageRaw) public class InAppMessageRaw : ObjectiveC.NSObject, Swift.Codable {
    public var id: Swift.String?
    public var type: BrazeKit.Braze.InAppMessageRaw.MessageType
    public var clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction
    @objc public var url: Foundation.URL?
    @objc public var useWebView: Swift.Bool
    public var messageClose: BrazeKit.Braze.InAppMessageRaw.MessageClose
    public var orientation: BrazeKit.Braze.InAppMessageRaw.Orientation
    @objc public var message: Swift.String?
    @objc public var header: Swift.String?
    public var messageTextAlignment: BrazeKit.Braze.InAppMessageRaw.TextAlignment?
    public var headerTextAlignment: BrazeKit.Braze.InAppMessageRaw.TextAlignment?
    @objc public var imageURL: Foundation.URL?
    @objc public var icon: Swift.String?
    public var duration: Foundation.TimeInterval?
    @objc public var themes: [Swift.String : BrazeKit.Braze.InAppMessageRaw.Theme]?
    @objc public var textColor: BrazeKit.Braze.InAppMessageRaw.Color?
    @objc public var headerTextColor: BrazeKit.Braze.InAppMessageRaw.Color?
    @objc public var iconColor: BrazeKit.Braze.InAppMessageRaw.Color?
    @objc public var iconBackgroundColor: BrazeKit.Braze.InAppMessageRaw.Color?
    @objc public var backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color?
    @objc public var frameColor: BrazeKit.Braze.InAppMessageRaw.Color?
    @objc public var closeButtonColor: BrazeKit.Braze.InAppMessageRaw.Color?
    @objc public var buttons: [BrazeKit.Braze.InAppMessageRaw.Button]?
    public var imageStyle: BrazeKit.Braze.InAppMessageRaw.ImageStyle?
    public var slideFrom: BrazeKit.Braze.InAppMessageRaw.SlideFrom?
    @objc public var animateIn: Swift.Bool
    @objc public var animateOut: Swift.Bool
    @objc public var extras: [Swift.String : Any] {
      @objc get
      @objc set
    }
    @objc public var messageExtras: Swift.String?
    @objc public var baseURL: Foundation.URL?
    @objc public var assetURLs: [Foundation.URL]?
    @objc public var isControl: Swift.Bool
    @objc public var isTestSend: Swift.Bool {
      @objc get
    }
    @objc public var messageFields: [Swift.String : Any]? {
      @objc get
      @objc set
    }
    @objc public var context: BrazeKit.Braze.InAppMessageRaw.Context?
    @objc public func json() -> Foundation.Data?
    @objc public static func decoding(json: Foundation.Data) -> Self?
    @objc override dynamic public init()
    public init(_ message: BrazeKit.Braze.InAppMessage)
    @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override dynamic public var hash: Swift.Int {
      @objc get
    }
    required public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @objc deinit
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  @_hasMissingDesignatedInitializers @objc(BRZInAppMessageRawButton) public class Button : ObjectiveC.NSObject, Swift.Codable {
    @objc(identifier) public var id: Swift.Int
    @objc public var text: Swift.String
    public var clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction
    @objc public var url: Foundation.URL?
    @objc public var useWebView: Swift.Bool
    @objc public var textColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc public var backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc public var borderColor: BrazeKit.Braze.InAppMessageRaw.Color
    public init(id: Swift.Int, text: Swift.String, clickAction: BrazeKit.Braze.InAppMessageRaw.ClickAction, url: Foundation.URL?, useWebView: Swift.Bool, textColor: BrazeKit.Braze.InAppMessageRaw.Color = ButtonTheme.defaultLight.textColor, backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color = ButtonTheme.defaultLight.backgroundColor, borderColor: BrazeKit.Braze.InAppMessageRaw.Color = ButtonTheme.defaultLight.borderColor)
    @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override dynamic public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
    public func encode(to encoder: any Swift.Encoder) throws
    required public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(BRZInAppMessageRawTheme) public class Theme : ObjectiveC.NSObject, Swift.Codable {
    @objc public static var defaultLight: BrazeKit.Braze.InAppMessageRaw.Theme {
      @objc get
    }
    @objc public static var defaultDark: BrazeKit.Braze.InAppMessageRaw.Theme {
      @objc get
    }
    @objc public var backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc public var textColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc public var iconColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc public var iconBackgroundColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc public var headerTextColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc public var closeButtonColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc public var frameColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc public var buttons: [BrazeKit.Braze.InAppMessageRaw.ButtonTheme]
    @objc convenience override dynamic public init()
    public init(backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color, textColor: BrazeKit.Braze.InAppMessageRaw.Color, iconColor: BrazeKit.Braze.InAppMessageRaw.Color, iconBackgroundColor: BrazeKit.Braze.InAppMessageRaw.Color, headerTextColor: BrazeKit.Braze.InAppMessageRaw.Color, closeButtonColor: BrazeKit.Braze.InAppMessageRaw.Color, frameColor: BrazeKit.Braze.InAppMessageRaw.Color, buttons: [BrazeKit.Braze.InAppMessageRaw.ButtonTheme])
    @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override dynamic public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
    public func encode(to encoder: any Swift.Encoder) throws
    required public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(BRZInAppMessageRawButtonTheme) public class ButtonTheme : ObjectiveC.NSObject, Swift.Codable {
    @objc public static var defaultLight: BrazeKit.Braze.InAppMessageRaw.ButtonTheme {
      @objc get
    }
    @objc public static var defaultDark: BrazeKit.Braze.InAppMessageRaw.ButtonTheme {
      @objc get
    }
    @objc public var textColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc public var borderColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc public var backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color
    @objc convenience override dynamic public init()
    public init(textColor: BrazeKit.Braze.InAppMessageRaw.Color, borderColor: BrazeKit.Braze.InAppMessageRaw.Color, backgroundColor: BrazeKit.Braze.InAppMessageRaw.Color)
    @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override dynamic public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
    public func encode(to encoder: any Swift.Encoder) throws
    required public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(BRZInAppMessageRawColor) public class Color : ObjectiveC.NSObject, Swift.Codable {
    @objc override dynamic public init()
    @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override dynamic public var hash: Swift.Int {
      @objc get
    }
    required public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @objc deinit
  }
}
extension BrazeKit.Braze.InAppMessageRaw {
  public enum MessageType : Swift.String, Swift.Codable {
    case slideup
    case modal
    case full
    case htmlFull
    case html
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ClickAction : Swift.String, Swift.Codable {
    case none
    case newsFeed
    case url
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum MessageClose : Swift.String, Swift.Codable {
    case autoDismiss
    case swipe
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Orientation : Swift.String, Swift.Codable {
    case any
    case portrait
    case landscape
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TextAlignment : Swift.String, Swift.Codable {
    case start
    case center
    case end
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ImageStyle : Swift.String, Swift.Codable {
    case graphic
    case top
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum SlideFrom : Swift.String, Swift.Codable {
    case top
    case bottom
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.InAppMessage {
  public init(_ message: BrazeKit.Braze.InAppMessageRaw) throws
}
extension BrazeKit.Braze.InAppMessage {
  public struct Theme : Swift.Hashable, Swift.Codable {
    public var backgroundColor: BrazeKit.Braze.InAppMessage.Color
    public var textColor: BrazeKit.Braze.InAppMessage.Color
    public var iconColor: BrazeKit.Braze.InAppMessage.Color
    public var iconBackgroundColor: BrazeKit.Braze.InAppMessage.Color
    public var headerTextColor: BrazeKit.Braze.InAppMessage.Color
    public var closeButtonColor: BrazeKit.Braze.InAppMessage.Color
    public var frameColor: BrazeKit.Braze.InAppMessage.Color
    public init(backgroundColor: BrazeKit.Braze.InAppMessage.Color = .clear, textColor: BrazeKit.Braze.InAppMessage.Color = .clear, iconColor: BrazeKit.Braze.InAppMessage.Color = .clear, iconBackgroundColor: BrazeKit.Braze.InAppMessage.Color = .clear, headerTextColor: BrazeKit.Braze.InAppMessage.Color = .clear, closeButtonColor: BrazeKit.Braze.InAppMessage.Color = .clear, frameColor: BrazeKit.Braze.InAppMessage.Color = .clear)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Theme, b: BrazeKit.Braze.InAppMessage.Theme) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Themes : Swift.Hashable, Swift.Codable, Swift.ExpressibleByDictionaryLiteral {
    public var light: BrazeKit.Braze.InAppMessage.Theme {
      get
      set
    }
    public var dark: BrazeKit.Braze.InAppMessage.Theme? {
      get
      set
    }
    public var themes: [Swift.String : BrazeKit.Braze.InAppMessage.Theme]
    public subscript(name: Swift.String) -> BrazeKit.Braze.InAppMessage.Theme? {
      get
      set
    }
    public init(themes: [Swift.String : BrazeKit.Braze.InAppMessage.Theme])
    public init(dictionaryLiteral elements: (Swift.String, BrazeKit.Braze.InAppMessage.Theme)...)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Themes, b: BrazeKit.Braze.InAppMessage.Themes) -> Swift.Bool
    public typealias Key = Swift.String
    public typealias Value = BrazeKit.Braze.InAppMessage.Theme
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ButtonTheme : Swift.Hashable, Swift.Codable {
    public var textColor: BrazeKit.Braze.InAppMessage.Color
    public var borderColor: BrazeKit.Braze.InAppMessage.Color
    public var backgroundColor: BrazeKit.Braze.InAppMessage.Color
    public init(textColor: BrazeKit.Braze.InAppMessage.Color = .clear, borderColor: BrazeKit.Braze.InAppMessage.Color = .clear, backgroundColor: BrazeKit.Braze.InAppMessage.Color = .clear)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.ButtonTheme, b: BrazeKit.Braze.InAppMessage.ButtonTheme) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ButtonThemes : Swift.Hashable, Swift.Codable, Swift.ExpressibleByDictionaryLiteral {
    public var light: BrazeKit.Braze.InAppMessage.ButtonTheme {
      get
    }
    public var dark: BrazeKit.Braze.InAppMessage.ButtonTheme? {
      get
    }
    public var themes: [Swift.String : BrazeKit.Braze.InAppMessage.ButtonTheme]
    public subscript(name: Swift.String) -> BrazeKit.Braze.InAppMessage.ButtonTheme? {
      get
    }
    public init(themes: [Swift.String : BrazeKit.Braze.InAppMessage.ButtonTheme])
    public init(dictionaryLiteral elements: (Swift.String, BrazeKit.Braze.InAppMessage.ButtonTheme)...)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.ButtonThemes, b: BrazeKit.Braze.InAppMessage.ButtonThemes) -> Swift.Bool
    public typealias Key = Swift.String
    public typealias Value = BrazeKit.Braze.InAppMessage.ButtonTheme
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessage.Theme {
  public static let defaultLight: BrazeKit.Braze.InAppMessage.Theme
  public static let defaultDark: BrazeKit.Braze.InAppMessage.Theme
}
extension BrazeKit.Braze.InAppMessage.ButtonTheme {
  public static let primary: BrazeKit.Braze.InAppMessage.ButtonTheme
  public static let secondary: BrazeKit.Braze.InAppMessage.ButtonTheme
  public static let defaultLight: BrazeKit.Braze.InAppMessage.ButtonTheme
  public static let defaultDark: BrazeKit.Braze.InAppMessage.ButtonTheme
}
extension BrazeKit.Braze.InAppMessage.Themes {
  public static let defaults: BrazeKit.Braze.InAppMessage.Themes
}
extension BrazeKit.Braze.InAppMessage.ButtonThemes {
  public static let defaults: BrazeKit.Braze.InAppMessage.ButtonThemes
}
public protocol BrazeInAppMessageThemeable {
  var themes: BrazeKit.Braze.InAppMessage.Themes { get }
}
extension BrazeKit.Braze.InAppMessage {
  public struct Slideup : BrazeKit.BrazeInAppMessageDataLookup, BrazeKit.BrazeInAppMessageThemeable, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var graphic: BrazeKit.Braze.InAppMessage.Graphic?
    public var message: Swift.String
    public var slideFrom: BrazeKit.Braze.InAppMessage.SlideFrom
    public var themes: BrazeKit.Braze.InAppMessage.Themes
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), graphic: BrazeKit.Braze.InAppMessage.Graphic? = nil, message: Swift.String = "", slideFrom: BrazeKit.Braze.InAppMessage.SlideFrom = .bottom, themes: BrazeKit.Braze.InAppMessage.Themes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Slideup, b: BrazeKit.Braze.InAppMessage.Slideup) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Modal : BrazeKit.BrazeInAppMessageDataLookup, BrazeKit.BrazeInAppMessageThemeable, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var graphic: BrazeKit.Braze.InAppMessage.Graphic?
    public var header: Swift.String
    public var headerTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment
    public var message: Swift.String
    public var messageTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment
    public var buttons: [BrazeKit.Braze.InAppMessage.Button]
    public var themes: BrazeKit.Braze.InAppMessage.Themes
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), graphic: BrazeKit.Braze.InAppMessage.Graphic? = nil, header: Swift.String = "", headerTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment = .center, message: Swift.String = "", messageTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment = .center, buttons: [BrazeKit.Braze.InAppMessage.Button] = [], themes: BrazeKit.Braze.InAppMessage.Themes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Modal, b: BrazeKit.Braze.InAppMessage.Modal) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ModalImage : BrazeKit.BrazeInAppMessageDataLookup, BrazeKit.BrazeInAppMessageThemeable, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var imageURL: Foundation.URL
    public var buttons: [BrazeKit.Braze.InAppMessage.Button]
    public var themes: BrazeKit.Braze.InAppMessage.Themes
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), imageURL: Foundation.URL, buttons: [BrazeKit.Braze.InAppMessage.Button] = [], themes: BrazeKit.Braze.InAppMessage.Themes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.ModalImage, b: BrazeKit.Braze.InAppMessage.ModalImage) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Full : BrazeKit.BrazeInAppMessageDataLookup, BrazeKit.BrazeInAppMessageThemeable, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var imageURL: Foundation.URL
    public var header: Swift.String
    public var headerTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment
    public var message: Swift.String
    public var messageTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment
    public var buttons: [BrazeKit.Braze.InAppMessage.Button]
    public var themes: BrazeKit.Braze.InAppMessage.Themes
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), imageURL: Foundation.URL, header: Swift.String = "", headerTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment = .center, message: Swift.String = "", messageTextAlignment: BrazeKit.Braze.InAppMessage.TextAlignment = .center, buttons: [BrazeKit.Braze.InAppMessage.Button] = [], themes: BrazeKit.Braze.InAppMessage.Themes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Full, b: BrazeKit.Braze.InAppMessage.Full) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct FullImage : BrazeKit.BrazeInAppMessageDataLookup, BrazeKit.BrazeInAppMessageThemeable, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var imageURL: Foundation.URL
    public var buttons: [BrazeKit.Braze.InAppMessage.Button]
    public var themes: BrazeKit.Braze.InAppMessage.Themes
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), imageURL: Foundation.URL, buttons: [BrazeKit.Braze.InAppMessage.Button] = [], themes: BrazeKit.Braze.InAppMessage.Themes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.FullImage, b: BrazeKit.Braze.InAppMessage.FullImage) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Html : BrazeKit.BrazeInAppMessageDataLookup, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public var message: Swift.String
    public var baseURL: Foundation.URL?
    public var assetURLs: Swift.Set<Foundation.URL>
    public var legacy: Swift.Bool
    public var messageFields: [Swift.String : Any] {
      get
      set
    }
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init(), message: Swift.String = "<html></html>", baseURL: Foundation.URL? = nil, assetURLs: Swift.Set<Foundation.URL> = [], legacy: Swift.Bool = false, messageFields: [Swift.String : Any] = [:])
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Html, b: BrazeKit.Braze.InAppMessage.Html) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Control : BrazeKit.BrazeInAppMessageDataLookup, Swift.Hashable, Swift.Codable {
    public var data: BrazeKit.Braze.InAppMessage.Data
    public init(data: BrazeKit.Braze.InAppMessage.Data = .init())
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Control, b: BrazeKit.Braze.InAppMessage.Control) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.InAppMessage {
  public enum ClickAction : Swift.Hashable, Swift.Codable {
    case none
    case newsFeed
    case url(Foundation.URL, useWebView: Swift.Bool)
    public var url: Foundation.URL? {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.ClickAction, b: BrazeKit.Braze.InAppMessage.ClickAction) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum MessageClose : Swift.Hashable, Swift.Codable {
    case userInteraction
    case auto(after: Foundation.TimeInterval)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.MessageClose, b: BrazeKit.Braze.InAppMessage.MessageClose) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public enum Orientation : Swift.String, Swift.Hashable, Swift.Codable {
    case any
    case portrait
    case landscape
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TextAlignment : Swift.String, Swift.Hashable, Swift.Codable {
    case leading
    case center
    case trailing
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Graphic : Swift.Hashable, Swift.Codable {
    case icon(Swift.String)
    case image(Foundation.URL)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Graphic, b: BrazeKit.Braze.InAppMessage.Graphic) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Button : Swift.Hashable, Swift.Codable {
    public var id: Swift.Int
    public var text: Swift.String
    public var clickAction: BrazeKit.Braze.InAppMessage.ClickAction
    public var themes: BrazeKit.Braze.InAppMessage.ButtonThemes
    public init(id: Swift.Int, text: Swift.String, clickAction: BrazeKit.Braze.InAppMessage.ClickAction, themes: BrazeKit.Braze.InAppMessage.ButtonThemes = .defaults)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.InAppMessage.Button, b: BrazeKit.Braze.InAppMessage.Button) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Color : Swift.RawRepresentable, Swift.Hashable, Swift.Codable, Swift.ExpressibleByIntegerLiteral {
    public var rawValue: Swift.UInt32
    public var r: Swift.Double {
      get
    }
    public var g: Swift.Double {
      get
    }
    public var b: Swift.Double {
      get
    }
    public var a: Swift.Double {
      get
    }
    public static let clear: BrazeKit.Braze.InAppMessage.Color
    public static let white: BrazeKit.Braze.InAppMessage.Color
    public static let black: BrazeKit.Braze.InAppMessage.Color
    public static let red: BrazeKit.Braze.InAppMessage.Color
    public static let green: BrazeKit.Braze.InAppMessage.Color
    public static let blue: BrazeKit.Braze.InAppMessage.Color
    public init(rawValue: Swift.UInt32)
    public init(red: Swift.Double, green: Swift.Double, blue: Swift.Double, alpha: Swift.Double)
    public init(integerLiteral value: Swift.UInt32)
    public typealias IntegerLiteralType = Swift.UInt32
    public typealias RawValue = Swift.UInt32
  }
  public enum SlideFrom : Swift.String, Swift.Hashable, Swift.Codable {
    case top
    case bottom
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.InAppMessage.Color {
  public var uiColor: UIKit.UIColor {
    get
  }
  public init(_ color: UIKit.UIColor)
}
extension BrazeKit.Braze.InAppMessageRaw.Color {
  @objc dynamic public var uiColor: UIKit.UIColor {
    @objc get
  }
  @objc convenience dynamic public init(_ color: UIKit.UIColor)
}
extension BrazeKit.Braze {
  @objc @_hasMissingDesignatedInitializers final public class LiveActivities : ObjectiveC.NSObject {
    @objc deinit
  }
}
extension BrazeKit.Braze.NewsFeed {
  @available(swift, obsoleted: 0.0.1)
  @objc(requestRefresh) final public func _objc_requestRefresh()
  @available(swift, obsoleted: 0.0.1)
  @objc(requestRefreshWithCompletion:) final public func _objc_requestRefresh(_ completion: @escaping ([BrazeKit.Braze.NewsFeedCard]?, (any Swift.Error)?) -> Swift.Void)
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZNewsFeed) final public class NewsFeed : ObjectiveC.NSObject {
    @objc final public var cards: [BrazeKit.Braze.NewsFeedCard] {
      @objc get
    }
    @objc final public var lastUpdate: Foundation.Date? {
      @objc get
    }
    final public func requestRefresh(_ completion: ((Swift.Result<[BrazeKit.Braze.NewsFeedCard], any Swift.Error>) -> Swift.Void)? = nil)
    @objc final public func subscribeToUpdates(_ update: @escaping ([BrazeKit.Braze.NewsFeedCard]) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    @objc deinit
  }
}
extension BrazeKit.Braze.NewsFeedCard {
  @available(swift, obsoleted: 0.0.1)
  @objc(type) dynamic public var _objc_type: BrazeKit.Braze.NewsFeedCard._OBJC_BRZNewsFeedCardType {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(categories) dynamic public var _objc_categories: [BrazeKit.Braze.NewsFeedCard._OBJC_BRZNewsFeedCardCategory] {
    @objc get
    @objc set
  }
  @available(swift, obsoleted: 0.0.1)
  @objc(imageAspectRatio) dynamic public var _objc_imageAspectRatio: Swift.Double {
    @objc get
    @objc set
  }
}
extension BrazeKit.Braze.NewsFeedCard {
  @objc(BRZNewsFeedCardType) public enum _OBJC_BRZNewsFeedCardType : Swift.Int {
    case classic
    case banner
    case captionedImage
    case textAnnouncement
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @_hasMissingDesignatedInitializers @objc(BRZNewsFeedCardCategory) final public class _OBJC_BRZNewsFeedCardCategory : ObjectiveC.NSObject {
    @objc public static let none: BrazeKit.Braze.NewsFeedCard._OBJC_BRZNewsFeedCardCategory
    @objc public static let news: BrazeKit.Braze.NewsFeedCard._OBJC_BRZNewsFeedCardCategory
    @objc public static let advertising: BrazeKit.Braze.NewsFeedCard._OBJC_BRZNewsFeedCardCategory
    @objc public static let announcements: BrazeKit.Braze.NewsFeedCard._OBJC_BRZNewsFeedCardCategory
    @objc public static let social: BrazeKit.Braze.NewsFeedCard._OBJC_BRZNewsFeedCardCategory
    @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override final public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
  }
}
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(BRZNewsFeedCard) public class NewsFeedCard : ObjectiveC.NSObject, Swift.Codable {
    @objc(identifier) public var id: Swift.String
    public var type: BrazeKit.Braze.NewsFeedCard.CardType
    @objc public var image: Foundation.URL?
    public var imageAspectRatio: Swift.Double?
    @objc public var title: Swift.String?
    @objc public var cardDescription: Swift.String?
    @objc public var domain: Swift.String?
    @objc public var url: Foundation.URL?
    @objc public var useWebView: Swift.Bool
    @objc public var extras: [Swift.String : Any] {
      @objc get
      @objc set
    }
    public var categories: [BrazeKit.Braze.NewsFeedCard.Category]
    @objc public var viewed: Swift.Bool
    @objc public var created: Swift.Double
    @objc public var updated: Swift.Double
    @objc public var expires: Swift.Double
    @objc public var context: BrazeKit.Braze.NewsFeedCard.Context?
    @objc override dynamic public init()
    @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override dynamic public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
    public func encode(to encoder: any Swift.Encoder) throws
    required public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.NewsFeedCard {
  public enum CardType : Swift.String, Swift.Codable {
    case classic
    case banner
    case captionedImage
    case textAnnouncement
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Category : Swift.String, Swift.Codable {
    case none
    case news
    case advertising
    case announcements
    case social
    public init(from decoder: any Swift.Decoder) throws
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.NewsFeedCard {
  @objc(BRZNewsFeedCardContext) final public class Context : ObjectiveC.NSObject {
    @objc public init(logImpression: @escaping () -> Swift.Void, logClick: @escaping () -> Swift.Void, processClickAction: @escaping (_ url: Foundation.URL, _ useWebView: Swift.Bool) -> Swift.Void)
    @objc convenience public init(card: BrazeKit.Braze.NewsFeedCard, using braze: BrazeKit.Braze)
    @objc final public func logImpression()
    @objc final public func logClick()
    @objc(processClickActionWithURL:useWebView:) final public func processClickAction(url: Foundation.URL, useWebView: Swift.Bool)
    @objc deinit
  }
}
extension BrazeKit.Braze.NewsFeedCard {
  @objc dynamic public func json() -> Foundation.Data?
  @objc public static func decoding(json: Foundation.Data) -> Self?
}
extension BrazeKit.Braze.NewsFeedCard {
  @objc dynamic public func logImpression(using braze: BrazeKit.Braze)
  @objc dynamic public func logClick(using braze: BrazeKit.Braze)
}
extension BrazeKit.Braze.Notifications {
  @available(swift, obsoleted: 0.0.1)
  @objc(registerDeviceToken:) final public func _objc_register(deviceToken: Foundation.Data)
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZNotifications) final public class Notifications : ObjectiveC.NSObject {
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    final public var notificationsStream: _Concurrency.AsyncStream<BrazeKit.Braze.Notifications.Payload> {
      get
    }
    @objc final public var deviceToken: Foundation.Data? {
      @objc get
    }
    final public func register(deviceToken: Foundation.Data, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    @objc final public func handleBackgroundNotification(userInfo: [Swift.AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIKit.UIBackgroundFetchResult) -> Swift.Void) -> Swift.Bool
    @objc final public func subscribeToUpdates(_ update: @escaping (BrazeKit.Braze.Notifications.Payload) -> Swift.Void) -> BrazeKit.Braze.Cancellable
    @objc public static func isBrazeNotification(_ userInfo: [Swift.AnyHashable : Any]) -> Swift.Bool
    @objc public static func isInternalNotification(_ userInfo: [Swift.AnyHashable : Any]) -> Swift.Bool
    @objc deinit
  }
}
extension BrazeKit.Braze.Notifications.Payload {
  @available(swift, obsoleted: 0.0.1)
  @objc(badge) dynamic public var _objc_badge: Foundation.NSNumber? {
    @objc get
  }
}
extension BrazeKit.Braze.Notifications {
  @_hasMissingDesignatedInitializers @objc(BRZNotificationsPayload) public class Payload : ObjectiveC.NSObject, Swift.Encodable {
    @objc public var title: Swift.String? {
      @objc get
    }
    @objc public var subtitle: Swift.String? {
      @objc get
    }
    @objc public var body: Swift.String? {
      @objc get
    }
    public var badge: Swift.Int? {
      get
    }
    @objc public var date: Foundation.Date {
      @objc get
    }
    @objc public var urlContext: BrazeKit.Braze.URLContext? {
      @objc get
    }
    @objc public var isSilent: Swift.Bool {
      @objc get
    }
    @objc public var isInternal: Swift.Bool {
      @objc get
    }
    @objc public var userInfo: [Swift.String : Any] {
      @objc get
    }
    public func encode(to encoder: any Swift.Encoder) throws
    @objc public func json() -> Foundation.Data?
    @objc public func userInfoJSON() -> Foundation.Data?
    @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
    @objc override dynamic public var hash: Swift.Int {
      @objc get
    }
    @objc deinit
  }
}
public var overrideResourcesBundle: Foundation.Bundle?
extension BrazeKit.Braze {
  @_inheritsConvenienceInitializers @objc(BRZResources) public class Resources : ObjectiveC.NSObject {
    @objc public static let bundle: Foundation.Bundle?
    @objc public static let acknowledgments: [Swift.String : Foundation.URL]
    @objc public static let license: Foundation.URL?
    @objc override dynamic public init()
    @objc deinit
  }
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZSDKAuthenticationError) public class SDKAuthenticationError : ObjectiveC.NSObject, Swift.Error {
    @objc final public let code: Swift.Int
    @objc final public let reason: Swift.String?
    @objc final public let userId: Swift.String?
    @objc final public let signature: Swift.String?
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers @objc(BRZSessionEvent) final public class _OBJC_BrazeSessionEvent : ObjectiveC.NSObject {
  @objc final public let sessionId: Foundation.UUID
  @objc final public let state: BrazeKit._OBJC_BrazeSessionState
  @objc deinit
}
@objc(BRZSessionState) public enum _OBJC_BrazeSessionState : Swift.Int {
  case started
  case ended
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension BrazeKit.Braze {
  public enum SessionEvent : Swift.Equatable {
    case started(Foundation.UUID)
    case ended(Foundation.UUID)
    public static func == (a: BrazeKit.Braze.SessionEvent, b: BrazeKit.Braze.SessionEvent) -> Swift.Bool
  }
}
extension BrazeKit.Braze {
  @objc(subscribeToSessionUpdates:) final public func _objc_subscribeToSessionUpdates(_ update: @escaping (BrazeKit._OBJC_BrazeSessionEvent) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
  final public var sessionUpdatesStream: _Concurrency.AsyncStream<BrazeKit.Braze.SessionEvent> {
    get
  }
  final public func subscribeToSessionUpdates(_ update: @escaping (BrazeKit.Braze.SessionEvent) -> Swift.Void) -> BrazeKit.Braze.Cancellable
}
extension BrazeKit.Braze {
  public enum UIUtils {
  }
}
extension BrazeKit.Braze.UIUtils {
  @available(iOS 13.0, tvOS 13.0, *)
  public static var activeWindowScene: UIKit.UIWindowScene? {
    get
  }
  public static var activeWindow: UIKit.UIWindow? {
    get
  }
  public static var activeRootViewController: UIKit.UIViewController? {
    get
  }
  public static var activeTopmostViewController: UIKit.UIViewController? {
    get
  }
  public static func preferredFont(textStyle: UIKit.UIFont.TextStyle, weight: UIKit.UIFont.Weight) -> UIKit.UIFont
}
extension BrazeKit.Braze {
  @objc(BRZURLContext) public class URLContext : ObjectiveC.NSObject, Swift.Codable {
    @objc public var url: Foundation.URL
    @objc public var useWebView: Swift.Bool
    @objc public var isUniversalLink: Swift.Bool
    final public let channel: BrazeKit.Braze.Channel
    @objc public var extras: [Swift.String : Any] {
      @objc get
    }
    @available(iOS 13.0, tvOS 13.0, *)
    @objc public var targetScene: UIKit.UIScene? {
      @objc get
      @objc set
    }
    @objc public var targetViewController: UIKit.UIViewController?
    public init(url: Foundation.URL, useWebView: Swift.Bool, channel: BrazeKit.Braze.Channel, extras: [Swift.String : Any])
    required public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    @objc deinit
  }
}
@objc extension BrazeKit.Braze.User {
  @objc @available(*, deprecated, renamed: "set(firstName:)")
  final public var firstName: Swift.String? {
    @objc get
    @objc(_compat_setFirstName:) set
  }
  @objc @available(*, deprecated, renamed: "set(lastName:)")
  final public var lastName: Swift.String? {
    @objc get
    @objc(_compat_setLastName:) set
  }
  @objc @available(*, deprecated, renamed: "set(email:)")
  final public var email: Swift.String? {
    @objc get
    @objc(_compat_setEmail:) set
  }
  @objc @available(*, deprecated, renamed: "set(dateOfBirth:)")
  final public var dateOfBirth: Foundation.Date? {
    @objc get
    @objc(_compat_setDateOfBirth:) set
  }
  @objc @available(*, deprecated, renamed: "set(country:)")
  final public var country: Swift.String? {
    @objc get
    @objc(_compat_setCountry:) set
  }
  @objc @available(*, deprecated, renamed: "set(homeCity:)")
  final public var homeCity: Swift.String? {
    @objc get
    @objc(_compat_setHomeCity:) set
  }
  @objc @available(*, deprecated, renamed: "set(language:)")
  final public var language: Swift.String? {
    @objc get
    @objc(_compat_setLanguage:) set
  }
  @objc @available(*, deprecated, renamed: "set(phoneNumber:)")
  final public var phone: Swift.String? {
    @objc get
    @objc(_compat_setPhone:) set
  }
  @available(*, deprecated, renamed: "id(queue:completion:)")
  @objc final public var userID: Swift.String? {
    @objc get
  }
  @available(*, deprecated, message: "avatarImageURL is not supported by Braze anymore")
  @objc final public var avatarImageURL: Swift.String? {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "facebookUser is not supported by Braze anymore")
  @objc final public var facebookUser: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @available(*, deprecated, message: "twitterUser is not supported by Braze anymore")
  @objc final public var twitterUser: Swift.AnyObject? {
    @objc get
    @objc set
  }
  @objc @available(*, deprecated, renamed: "set(attributionData:)")
  final public var attributionData: Swift.AnyObject? {
    @objc get
    @objc(_compat_setAttributionData:) set
  }
  @available(*, deprecated, renamed: "add(alias:label:)")
  @objc final public func addAlias(_ alias: Swift.String, withLabel label: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "set(gender:)")
  @nonobjc final public func setGender<T>(_ gender: T) -> Swift.Bool where T : Swift.RawRepresentable, T.RawValue == Swift.Int
  @available(*, deprecated, renamed: "set(gender:)")
  @nonobjc final public func setGender(_ gender: BrazeKit.Braze.User.Gender) -> Swift.Bool
  @available(*, deprecated, renamed: "set(emailSubscriptionState:)")
  @nonobjc final public func setEmailNotificationSubscriptionType<T>(_ emailNotificationSubscriptionType: T) -> Swift.Bool where T : Swift.RawRepresentable, T.RawValue == Swift.Int
  @available(*, deprecated, renamed: "set(emailSubscriptionState:)")
  @objc final public func setEmailNotificationSubscriptionType(_ emailNotificationSubscriptionType: Swift.Int) -> Swift.Bool
  @available(*, deprecated, renamed: "set(pushNotificationSubscriptionState:)")
  @nonobjc final public func setPush<T>(_ pushNotificationSubscriptionType: T) -> Swift.Bool where T : Swift.RawRepresentable, T.RawValue == Swift.Int
  @available(*, deprecated, renamed: "set(pushNotificationSubscriptionState:)")
  @objc(setPushNotificationSubscriptionType:) final public func setPush(_ pushNotificationSubscriptionType: Swift.Int) -> Swift.Bool
  @available(*, deprecated, renamed: "addToSubscriptionGroup(id:)")
  @nonobjc final public func addToSubscriptionGroup(withGroupId groupId: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "removeFromSubscriptionGroup(id:)")
  @nonobjc final public func removeFromSubscriptionGroup(withGroupId groupId: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttribute(key:value:)")
  @objc final public func setCustomAttributeWithKey(_ key: Swift.String, andBOOLValue value: Swift.Bool) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttribute(key:value:)")
  @objc final public func setCustomAttributeWithKey(_ key: Swift.String, andIntegerValue value: Swift.Int) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttribute(key:value:)")
  @objc final public func setCustomAttributeWithKey(_ key: Swift.String, andDoubleValue value: Swift.Double) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttribute(key:value:)")
  @objc final public func setCustomAttributeWithKey(_ key: Swift.String, andStringValue value: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttribute(key:value:)")
  @objc final public func setCustomAttributeWithKey(_ key: Swift.String, andDateValue value: Foundation.Date) -> Swift.Bool
  @available(*, deprecated, renamed: "unsetCustomAttribute(key:)")
  @nonobjc final public func unsetCustomAttribute(withKey key: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "incrementCustomUserAttribute(key:by:)")
  @nonobjc final public func incrementCustomUserAttribute(_ key: Swift.String, by amount: Swift.Int = 1) -> Swift.Bool
  @available(*, deprecated, renamed: "addToCustomAttributeStringArray(key:value:)")
  @nonobjc final public func addToCustomAttributeArray(withKey key: Swift.String, value: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "removeFromCustomAttributeStringArray(key:value:)")
  @nonobjc final public func removeFromCustomAttributeArray(withKey key: Swift.String, value: Swift.String) -> Swift.Bool
  @available(*, deprecated, renamed: "setCustomAttributeArray(key:array:)")
  @nonobjc final public func setCustomAttributeArrayWithKey(_ key: Swift.String, array: [Swift.String]?) -> Swift.Bool
  @available(*, deprecated, renamed: "setLastKnownLocation(latitude:longitude:altitude:horizontalAccuracy:verticalAccuracy:)")
  @nonobjc final public func setLastKnownLocationWithLatitude(_ latitude: Swift.Double, longitude: Swift.Double, horizontalAccuracy: Swift.Double) -> Swift.Bool
  @available(*, deprecated, renamed: "setLastKnownLocation(latitude:longitude:altitude:horizontalAccuracy:verticalAccuracy:)")
  @objc final public func setLastKnownLocationWithLatitude(_ latitude: Swift.Double, longitude: Swift.Double, horizontalAccuracy: Swift.Double, altitude: Swift.Double, verticalAccuracy: Swift.Double) -> Swift.Bool
  @available(*, deprecated, renamed: "setLocationCustomAttribute(key:latitude:longitude:)")
  @objc final public func addLocationCustomAttribute(withKey key: Swift.String, latitude: Swift.Double, longitude: Swift.Double) -> Swift.Bool
  @available(*, deprecated, renamed: "unsetLocationCustomAttribute(key:)")
  @objc final public func removeLocationCustomAttribute(withKey key: Swift.String) -> Swift.Bool
}
extension BrazeKit.Braze.User {
  @objc(idWithCompletion:) final public func _objc_id(completion: @escaping (Swift.String?) -> Swift.Void)
  @available(swift, obsoleted: 0.0.1)
  @objc(setEmail:) final public func _objc_set(email: Swift.String?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setLanguage:) final public func _objc_set(language: Swift.String?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setGender:) final public func _objc_set(gender: BrazeKit._OBJC_BRZUserGender?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setEmailSubscriptionState:) final public func _objc_set(emailSubscriptionState: BrazeKit._OBJC_BRZUserSubscriptionState)
  @available(swift, obsoleted: 0.0.1)
  @objc(setPushNotificationSubscriptionState:) final public func _objc_set(pushNotificationSubscriptionState: BrazeKit._OBJC_BRZUserSubscriptionState)
  @available(swift, obsoleted: 0.0.1)
  @objc(setAttributionData:) final public func _objc_set(attributionData: BrazeKit._OBJC_BRZUserAttributionData?)
  @available(swift, obsoleted: 0.0.1)
  @objc(addAlias:label:) final public func _objc_add(alias: Swift.String, label: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeWithKey:boolValue:) final public func _objc_setCustomAttribute(key: Swift.String, boolValue: Swift.Bool)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeWithKey:doubleValue:) final public func _objc_setDoubleCustomAttribute(key: Swift.String, doubleValue: Swift.Double)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeWithKey:intValue:) final public func _objc_setIntCustomAttribute(key: Swift.String, intValue: Swift.Int)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeWithKey:stringValue:) final public func _objc_setStringCustomAttribute(key: Swift.String, stringValue: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeWithKey:dateValue:) final public func _objc_setDateCustomAttribute(key: Swift.String, dateValue: Foundation.Date)
  @available(swift, obsoleted: 0.0.1)
  @objc(unsetCustomAttributeWithKey:) final public func _objc_unsetCustomAttribute(key: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(incrementCustomUserAttribute:) final public func _objc_incrementCustomUserAttribute(key: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(incrementCustomUserAttribute:by:) final public func _objc_incrementCustomUserAttribute(key: Swift.String, by amount: Swift.Int)
  @available(swift, obsoleted: 0.0.1)
  @objc(addToCustomAttributeStringArrayWithKey:value:) final public func _objc_addToCustomAttributeStringArray(key: Swift.String, value: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(removeFromCustomAttributeStringArrayWithKey:value:) final public func _objc_removeFromCustomAttributeStringArray(key: Swift.String, value: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(setCustomAttributeArrayWithKey:array:) final public func _objc_setCustomAttributeArray(key: Swift.String, array: [Swift.String]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setNestedCustomAttributeArrayWithKey:value:) final public func _objc_setNestedCustomAttributeArray(key: Swift.String, array: [[Swift.String : Any]]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setNestedCustomAttributeDictionaryWithKey:value:) final public func _objc_setNestedCustomAttributeDictionary(key: Swift.String, dictionary: [Swift.String : Any]?)
  @available(swift, obsoleted: 0.0.1)
  @objc(setNestedCustomAttributeDictionaryWithKey:value:merge:) final public func _objc_setNestedCustomAttributeDictionary(key: Swift.String, dictionary: [Swift.String : Any]?, merge: Swift.Bool)
  @available(swift, obsoleted: 0.0.1)
  @objc(setLastKnownLocationWithLatitude:longitude:horizontalAccuracy:) final public func _objc_setLastKnownLocation(latitude: Swift.Double, longitude: Swift.Double, horizontalAccuracy: Swift.Double)
  @available(swift, obsoleted: 0.0.1)
  @objc(setLastKnownLocationWithLatitude:longitude:altitude:horizontalAccuracy:verticalAccuracy:) final public func _objc_setLastKnownLocation(latitude: Swift.Double, longitude: Swift.Double, altitude: Swift.Double, horizontalAccuracy: Swift.Double, verticalAccuracy: Swift.Double)
  @available(swift, obsoleted: 0.0.1)
  @objc(setLocationCustomAttributeWithKey:latitude:longitude:) final public func _objc_setLocationCustomAttribute(key: Swift.String, latitude: Swift.Double, longitude: Swift.Double)
  @available(swift, obsoleted: 0.0.1)
  @objc(unsetLocationCustomAttributeWithKey:) final public func _objc_unsetLocationCustomAttribute(key: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(addToSubscriptionGroupWithGroupId:) final public func _objc_addToSubscriptionGroup(id: Swift.String)
  @available(swift, obsoleted: 0.0.1)
  @objc(removeFromSubscriptionGroupWithGroupId:) final public func _objc_removeFromSubscriptionGroup(id: Swift.String)
}
@_hasMissingDesignatedInitializers @objc(BRZUserGender) public class _OBJC_BRZUserGender : ObjectiveC.NSObject {
  @objc public static let male: BrazeKit._OBJC_BRZUserGender
  @objc public static let female: BrazeKit._OBJC_BRZUserGender
  @objc public static let other: BrazeKit._OBJC_BRZUserGender
  @objc public static let unknown: BrazeKit._OBJC_BRZUserGender
  @objc public static let notApplicable: BrazeKit._OBJC_BRZUserGender
  @objc public static let preferNotToSay: BrazeKit._OBJC_BRZUserGender
  @objc deinit
}
@objc(BRZUserSubscriptionState) public enum _OBJC_BRZUserSubscriptionState : Swift.Int {
  case optedIn
  case subscribed
  case unsubscribed
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc(BRZUserAttributionData) public class _OBJC_BRZUserAttributionData : ObjectiveC.NSObject {
  @objc public var network: Swift.String? {
    @objc get
  }
  @objc public var campaign: Swift.String? {
    @objc get
  }
  @objc public var adGroup: Swift.String? {
    @objc get
  }
  @objc public var creative: Swift.String? {
    @objc get
  }
  @objc public init(network: Swift.String?, campaign: Swift.String?, adGroup: Swift.String?, creative: Swift.String?)
  @objc deinit
}
extension BrazeKit.Braze {
  @_hasMissingDesignatedInitializers @objc(BRZUser) final public class User : ObjectiveC.NSObject {
    @objc(idOnQueue:completion:) final public func id(queue: Dispatch.DispatchQueue = .main, completion: @escaping (Swift.String?) -> Swift.Void)
    #if compiler(>=5.3) && $AsyncAwait
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, macCatalyst 15.0, *)
    final public func id() async -> Swift.String?
    #endif
    @objc(setFirstName:) final public func set(firstName: Swift.String?)
    @objc(setLastName:) final public func set(lastName: Swift.String?)
    final public func set(email: Swift.String?, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    @objc(setDateOfBirth:) final public func set(dateOfBirth: Foundation.Date?)
    @objc(setCountry:) final public func set(country: Swift.String?)
    @objc(setHomeCity:) final public func set(homeCity: Swift.String?)
    final public func set(language: Swift.String?, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func set(gender: BrazeKit.Braze.User.Gender?)
    @objc(setPhoneNumber:) final public func set(phoneNumber: Swift.String?)
    final public func set(emailSubscriptionState: BrazeKit.Braze.User.SubscriptionState)
    final public func set(pushNotificationSubscriptionState: BrazeKit.Braze.User.SubscriptionState)
    final public func set(attributionData: BrazeKit.Braze.User.AttributionData?)
    final public func add(alias: Swift.String, label: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, value: Swift.Bool, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, value: Swift.Double, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, value: Swift.Int, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, value: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, value: Foundation.Date, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func unsetCustomAttribute(key: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func incrementCustomUserAttribute(key: Swift.String, by amount: Swift.Int = 1, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func addToCustomAttributeStringArray(key: Swift.String, value: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func removeFromCustomAttributeStringArray(key: Swift.String, value: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, array: [Swift.String]?, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, array: [[Swift.String : Any?]], fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setCustomAttribute(key: Swift.String, dictionary: [Swift.String : Any?], merge: Swift.Bool = false, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setLastKnownLocation(latitude: Swift.Double, longitude: Swift.Double, altitude: Swift.Double? = nil, horizontalAccuracy: Swift.Double? = nil, verticalAccuracy: Swift.Double? = nil, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func setLocationCustomAttribute(key: Swift.String, latitude: Swift.Double, longitude: Swift.Double, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func unsetLocationCustomAttribute(key: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func addToSubscriptionGroup(id: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    final public func removeFromSubscriptionGroup(id: Swift.String, fileID: Swift.StaticString = #fileID, line: Swift.UInt = #line)
    @objc deinit
  }
}
extension BrazeKit.Braze.User {
  public struct AttributionData : Swift.Hashable, Swift.Codable {
    public let network: Swift.String?
    public let campaign: Swift.String?
    public let adGroup: Swift.String?
    public let creative: Swift.String?
    public init(network: Swift.String? = nil, campaign: Swift.String? = nil, adGroup: Swift.String? = nil, creative: Swift.String? = nil)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.User.AttributionData, b: BrazeKit.Braze.User.AttributionData) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.User {
  public enum Gender : Swift.String, Swift.Codable, Swift.CaseIterable {
    case male
    case female
    case other
    case unknown
    case notApplicable
    case preferNotToSay
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.User.Gender]
    public typealias RawValue = Swift.String
    public static var allCases: [BrazeKit.Braze.User.Gender] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.User {
  public struct PushToStartToken : Swift.Hashable, Swift.Codable {
    public func encode(to encoder: any Swift.Encoder) throws
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: BrazeKit.Braze.User.PushToStartToken, b: BrazeKit.Braze.User.PushToStartToken) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension BrazeKit.Braze.User {
  public enum SubscriptionGroupStatus : Swift.String, Swift.Codable, Swift.CaseIterable {
    case subscribed
    case unsubscribed
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.User.SubscriptionGroupStatus]
    public typealias RawValue = Swift.String
    public static var allCases: [BrazeKit.Braze.User.SubscriptionGroupStatus] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze.User {
  public enum SubscriptionState : Swift.String, Swift.Codable, Swift.CaseIterable {
    case optedIn
    case subscribed
    case unsubscribed
    public init?(rawValue: Swift.String)
    public typealias AllCases = [BrazeKit.Braze.User.SubscriptionState]
    public typealias RawValue = Swift.String
    public static var allCases: [BrazeKit.Braze.User.SubscriptionState] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension BrazeKit.Braze {
  public enum WebViewBridge {
  }
}
extension BrazeKit.Braze.WebViewBridge {
  public struct QueryHandler {
    public init(logClick: @escaping (Swift.String?) -> Swift.Void, logError: @escaping (BrazeKit.Braze.WebViewBridge.QueryHandler.Error) -> Swift.Void)
    public enum Error : Swift.Error, Swift.Hashable {
      case invalidButtonId(Swift.String?)
      public func hash(into hasher: inout Swift.Hasher)
      public static func == (a: BrazeKit.Braze.WebViewBridge.QueryHandler.Error, b: BrazeKit.Braze.WebViewBridge.QueryHandler.Error) -> Swift.Bool
      public var hashValue: Swift.Int {
        get
      }
    }
    public func process(url: Foundation.URL, logBodyClick: Swift.Bool = true) -> (BrazeKit.Braze.InAppMessage.ClickAction, Swift.String?)
  }
}
extension BrazeKit._COMPAT_ABKRequestProcessingPolicy : Swift.Equatable {}
extension BrazeKit._COMPAT_ABKRequestProcessingPolicy : Swift.Hashable {}
extension BrazeKit._COMPAT_ABKRequestProcessingPolicy : Swift.RawRepresentable {}
extension BrazeKit._COMPAT_ABKSDKFlavor : Swift.Equatable {}
extension BrazeKit._COMPAT_ABKSDKFlavor : Swift.Hashable {}
extension BrazeKit._COMPAT_ABKSDKFlavor : Swift.RawRepresentable {}
extension BrazeKit._COMPAT_ABKSdkMetadata : Swift.Equatable {}
extension BrazeKit._COMPAT_ABKSdkMetadata : Swift.Hashable {}
extension BrazeKit._COMPAT_ABKSdkMetadata : Swift.RawRepresentable {}
extension BrazeKit._OBJC_TriggerEvent : Swift.Equatable {}
extension BrazeKit._OBJC_TriggerEvent : Swift.Hashable {}
extension BrazeKit._OBJC_TriggerEvent : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessage.SlideFrom : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessage.TextAlignment : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessage.Orientation : Swift.RawRepresentable {}
extension BrazeKit._OBJC_BRZChannel : Swift.Equatable {}
extension BrazeKit._OBJC_BRZChannel : Swift.Hashable {}
extension BrazeKit._OBJC_BRZChannel : Swift.RawRepresentable {}
extension BrazeKit.Braze.Channel : Swift.Equatable {}
extension BrazeKit.Braze.Channel : Swift.Hashable {}
extension BrazeKit.Braze.Channel : Swift.RawRepresentable {}
extension BrazeKit._OBJC_BRZRequestPolicy : Swift.Equatable {}
extension BrazeKit._OBJC_BRZRequestPolicy : Swift.Hashable {}
extension BrazeKit._OBJC_BRZRequestPolicy : Swift.RawRepresentable {}
extension BrazeKit._OBJC_BRZSDKFlavor : Swift.Equatable {}
extension BrazeKit._OBJC_BRZSDKFlavor : Swift.Hashable {}
extension BrazeKit._OBJC_BRZSDKFlavor : Swift.RawRepresentable {}
extension BrazeKit.Braze.Configuration.Api.RequestPolicy : Swift.Equatable {}
extension BrazeKit.Braze.Configuration.Api.RequestPolicy : Swift.Hashable {}
extension BrazeKit.Braze.Configuration.Api.RequestPolicy : Swift.RawRepresentable {}
extension BrazeKit.Braze.Configuration.Api.SDKFlavor : Swift.Equatable {}
extension BrazeKit.Braze.Configuration.Api.SDKFlavor : Swift.Hashable {}
extension BrazeKit.Braze.Configuration.Api.SDKFlavor : Swift.RawRepresentable {}
extension BrazeKit.Braze.Configuration.Api.SDKMetadata : Swift.Equatable {}
extension BrazeKit.Braze.Configuration.Api.SDKMetadata : Swift.Hashable {}
extension BrazeKit.Braze.Configuration.Api.SDKMetadata : Swift.RawRepresentable {}
extension BrazeKit.Braze.Configuration.DeviceProperty : Swift.Equatable {}
extension BrazeKit.Braze.Configuration.DeviceProperty : Swift.Hashable {}
extension BrazeKit.Braze.Configuration.DeviceProperty : Swift.RawRepresentable {}
extension BrazeKit.Braze.Configuration.Logger.Level : Swift.Equatable {}
extension BrazeKit.Braze.Configuration.Logger.Level : Swift.Hashable {}
extension BrazeKit.Braze.Configuration.Logger.Level : Swift.RawRepresentable {}
extension BrazeKit.Braze.ContentCardRaw._OBJC_BRZContentCardRawType : Swift.Equatable {}
extension BrazeKit.Braze.ContentCardRaw._OBJC_BRZContentCardRawType : Swift.Hashable {}
extension BrazeKit.Braze.ContentCardRaw._OBJC_BRZContentCardRawType : Swift.RawRepresentable {}
extension BrazeKit.Braze.ContentCardRaw.CardType : Swift.Equatable {}
extension BrazeKit.Braze.ContentCardRaw.CardType : Swift.Hashable {}
extension BrazeKit.Braze.ContentCardRaw.CardType : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawType : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawType : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawType : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClickAction : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClose : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClose : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawClose : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawOrientation : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawOrientation : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawOrientation : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawTextAlignment : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawTextAlignment : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawTextAlignment : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawImageStyle : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawImageStyle : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawImageStyle : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawSlideFrom : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawSlideFrom : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw._OBJC_BRZInAppMessageRawSlideFrom : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageType : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageType : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageType : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.ClickAction : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.ClickAction : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.ClickAction : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageClose : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageClose : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.MessageClose : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.Orientation : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.Orientation : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.Orientation : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.TextAlignment : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.TextAlignment : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.TextAlignment : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.ImageStyle : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.ImageStyle : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.ImageStyle : Swift.RawRepresentable {}
extension BrazeKit.Braze.InAppMessageRaw.SlideFrom : Swift.Equatable {}
extension BrazeKit.Braze.InAppMessageRaw.SlideFrom : Swift.Hashable {}
extension BrazeKit.Braze.InAppMessageRaw.SlideFrom : Swift.RawRepresentable {}
extension BrazeKit.Braze.NewsFeedCard._OBJC_BRZNewsFeedCardType : Swift.Equatable {}
extension BrazeKit.Braze.NewsFeedCard._OBJC_BRZNewsFeedCardType : Swift.Hashable {}
extension BrazeKit.Braze.NewsFeedCard._OBJC_BRZNewsFeedCardType : Swift.RawRepresentable {}
extension BrazeKit.Braze.NewsFeedCard.CardType : Swift.Equatable {}
extension BrazeKit.Braze.NewsFeedCard.CardType : Swift.Hashable {}
extension BrazeKit.Braze.NewsFeedCard.CardType : Swift.RawRepresentable {}
extension BrazeKit.Braze.NewsFeedCard.Category : Swift.Equatable {}
extension BrazeKit.Braze.NewsFeedCard.Category : Swift.Hashable {}
extension BrazeKit.Braze.NewsFeedCard.Category : Swift.RawRepresentable {}
extension BrazeKit._OBJC_BrazeSessionState : Swift.Equatable {}
extension BrazeKit._OBJC_BrazeSessionState : Swift.Hashable {}
extension BrazeKit._OBJC_BrazeSessionState : Swift.RawRepresentable {}
extension BrazeKit._OBJC_BRZUserSubscriptionState : Swift.Equatable {}
extension BrazeKit._OBJC_BRZUserSubscriptionState : Swift.Hashable {}
extension BrazeKit._OBJC_BRZUserSubscriptionState : Swift.RawRepresentable {}
extension BrazeKit.Braze.User.Gender : Swift.Equatable {}
extension BrazeKit.Braze.User.Gender : Swift.Hashable {}
extension BrazeKit.Braze.User.Gender : Swift.RawRepresentable {}
extension BrazeKit.Braze.User.SubscriptionGroupStatus : Swift.Equatable {}
extension BrazeKit.Braze.User.SubscriptionGroupStatus : Swift.Hashable {}
extension BrazeKit.Braze.User.SubscriptionGroupStatus : Swift.RawRepresentable {}
extension BrazeKit.Braze.User.SubscriptionState : Swift.Equatable {}
extension BrazeKit.Braze.User.SubscriptionState : Swift.Hashable {}
extension BrazeKit.Braze.User.SubscriptionState : Swift.RawRepresentable {}
